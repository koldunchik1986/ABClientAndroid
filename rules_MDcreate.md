## Анализ папки

Когда поступает задача проанализировать целую папку, необходимо создать сводный markdown-файл для отслеживания прогресса **анализа** каждого файла в этой папке. Для отслеживания общего прогресса **реализации** используется сводный файл верхнего уровня (например, `todo_ABClient.md`).

### Статус-маркеры

*   `[ ]` - **Не проанализирован**: Детальный анализ файла еще не проводился.
*   `[x]` - **Проанализирован**: Детальный анализ файла (`todo_filename.md`) завершен.
*   `[-]` - **Отложен**: Анализ или реализация отложены.
*   `[+]` - **Реализован/Портирован**: Весь функционал, описанный в файле или папке, полностью реализован в Android-версии.

### Шаг 1: Создание сводного файла анализа папки (`todo_FolderName.md`)

1.  **Расположение:** `TODO\todo_FolderName.md`.
2.  **Назначение:** Отслеживать **статус анализа** каждого файла внутри папки `FolderName`.
3.  **Структура:**

    ```markdown
    # Анализ папки [FolderName]

    ## Список файлов и статус анализа

    | Файл             | Описание                               | Статус подробного анализа |
    | ---------------- | -------------------------------------- | ------------------------- |
    | `[FileName1.cs]` | [Краткое описание]                     | `[ ]` Не проанализирован      |
    | `[FileName2.cs]` | [Краткое описание]                     | `[x]` Проанализирован         |
    ```

### Шаг 2: Обновление сводного файла проекта (`todo_ProjectName.md`)

1.  **Расположение:** `TODO\todo_ProjectName.md` (например, `TODO\todo_ABClient.md`).
2.  **Назначение:** Отслеживать общий **статус реализации (портирования)** для каждой папки.
3.  **Процесс:**
    *   Когда **все** задачи по портированию функционала из папки `FolderName` выполнены (то есть, все ее файлы не просто проанализированы, а их функционал реализован в Android), статус этой папки в файле `todo_ProjectName.md` меняется на `[+]`.

    ```markdown
    # Анализ папки ABClient

    ## Список подпапок и статус реализации

    | Папка     | Описание                               | Статус реализации |
    | --------- | -------------------------------------- | ----------------- |
    | `Forms`   | Основные формы и диалоги.              | `[+]` Реализована     |
    | `Helpers` | Вспомогательные классы.                | `[ ]` Не реализована  |
    ```


### Шаг 3: Процесс работы

### Шаг 3: Процесс работы

1.  **Первичное сканирование и проверка:**
    *   Получите список **всех файлов** (включая `.cs`, `.xml`, `.js`, `.resx` и т.д.) в анализируемой папке (например, `ABClient\PostFilter`).
    *   Получите список всех `.md` файлов в соответствующей папке с анализами (например, `TODO\todo_ABClient\todo_PostFilter`).
    *   В сводном файле `todo_PostFilter.md` создайте таблицу и изначально пометьте все файлы статусом `[ ] Не проанализирован`, если для них еще не создан детальный `.md` файл.
    *   **Проверьте соответствие существующих `.md` файлов:** Одновременно просмотрите соответствующую папку с анализами (`TODO\todo_ABClient\todo_PostFilter`). Если в ней есть файлы `todo_*.md`, убедитесь, что они действительно описывают файлы из папки `ABClient\PostFilter`. Если найден несоответствующий файл, сообщите об этом.
    *   **Сравните количество и состав файлов:** Убедитесь, что для каждого файла в исходной папке существует соответствующий `todo_filename.filetype.md` файл в папке анализа.
    *   **При расхождении:** Если обнаружено, что для какого-либо файла отсутствует `.md` файл, необходимо немедленно создать его, проведя подробный анализ этого файла и занеся результаты в новый `.md` файл согласно общим инструкциям.
    *   **Проверьте соответствие существующих `.md` файлов:** Если в папке анализа есть файлы `todo_*.md`, убедитесь, что они действительно описывают существующие файлы в исходной папке. Если найден несоответствующий `.md` файл (описывающий удаленный или переименованный исходный файл), сообщите об этом.
    *   Для каждого файла в исходной папке постарайтесь дать краткое описание его назначения в сводном файле `todo_FolderName.md`.
    *   В сводном файле `todo_FolderName.md` создайте или обновите таблицу, помечая все файлы, для которых еще не создан детальный `.md` файл, статусом `[ ] Не проанализирован`.

2.  **Детальный анализ файла:**
    *   Когда вы приступаете к детальному анализу конкретного файла (например, `FileName1.cs` из папки `FolderName`), вы создаете для него отдельный файл в **новой подпапке** внутри `TODO`.
    *   **Расположение:** `TODO\FolderName\todo_FileName1.cs.md`

3.  **Обновление сводного файла:**
    *   После завершения (или переноса) детального анализа файла, **обязательно обновите статус** этого файла в сводном файле `TODO\todo_FolderName.md`.
    *   Измените `[ ]` на `[x]` (проанализирован) или `[-]` (отложен).
    *   Это позволяет иметь высокоуровневое представление о прогрессе анализа всей папки.

**Шаг 4: Завершение реализации файла**

1.  Когда все задачи в разделе "План реализации" файла `TODO\FolderName\todo_FileName.cs.md` отмечены как выполненные (`[x]`), это означает, что портирование функциональности из `FileName.cs` завершено.
2.  После этого необходимо **обязательно обновить статус** этого файла в сводном файле `TODO\todo_FolderName.md`.
3.  Измените статус с `[x] Проанализирован` на `[+] Реализован`.

**Пример использования:**

1.  **Задача:** "Проанализируй папку `ABClient\Forms`".
2.  **Действие:**
    *   Проверяем, есть ли `TODO\todo_Forms.md`. Нет.
    *   Создаем `TODO\todo_Forms.md`.
    *   Сканируем папку `ABClient\Forms`, находим `FormProfile.cs`, `FormProfiles.cs` и т.д.
    *   Заполняем таблицу в `TODO\todo_Forms.md`.

3.  **Задача:** "Проанализируй `FormProfile.cs` из папки `Forms`".
4.  **Действие:**
    *   Создаем подпапку `TODO\Forms` (если ее нет).
    *   Создаем `TODO\Forms\todo_FormProfile.cs.md` и проводим детальный анализ.
    *   После завершения, открываем `TODO\todo_Forms.md` и обновляем статус для `FormProfile.cs` на `[x] Проанализирован`.


# Инструкция по созданию подробного анализа для портирования

## Основные правила

1.  **Подробный анализ:** При выполнении портирования кода с ПК версии (C#) на Android (Java/Kotlin) необходимо сначала провести подробный анализ исходного файла. Результаты анализа должны быть записаны в файл `TODO\FolderName\todo_filename.cs.md` на русском языке.
2.  **Соблюдение названий:** Обязательно соблюдать названия переменных, функций и констант из ПК версии в Android версии для сохранения преемственности и облегчения отладки.
3.  **Ведение списка задач:** Всегда вести подробный список задач в файле `todo_task_timestamp.md` на русском языке и обновлять его по мере выполнения.

## Процесс портирования

### Шаг 1: Анализ и документирование

1.  **Анализ исходного C# файла:**
    *   **Задача:** Полностью понять, что делает класс, его методы, с какими данными и UI он работает в оригинальном приложении.
    *   Это первый и самый важный шаг в `todo_filename.cs.md`.

2.  **Проверка на существующую реализацию в Android:**
    *   **Когда:** *После* того, как вы полностью поняли функциональность C# кода.
    *   **Как:** Искать в Android-проекте по ключевым словам, названиям классов, уникальным строкам.
    *   **Результат:** Этот шаг определяет дальнейший план. Либо мы портируем с нуля, либо дорабатываем существующий код.

3.  **Написание плана портирования:**
    *   На основе результатов предыдущих двух шагов составляется детальный план действий для Android-версии.
    *   **Промпт для анализа:** Перед созданием кода портированного приложения, необходимо проанализировать текущий код Android приложения на наличие уже присутствующих элементов. Если их нет, то уже реализовывать подробно.

**Фраза-триггер:** *"Обязательно производить сначала запись анализа и подробных описаний и инструкций в TODO\todo_filename.filetype.md на руссокм языке, а после уже приступать к написанию кода..."*

**Расшифровка:**

После того как вы убедились, что функциональность не реализована, приступайте к анализу и документированию:

1.  **Полностью проанализировать исходный файл** из ПК-версии (например, `MyClass.cs`).
2.  **Создать markdown-файл** в папке `TODO` с именем, соответствующим исходному файлу (например, `TODO\todo_MyClass.cs.md`).
3.  **Заполнить этот файл подробной информацией** на русском языке, включая:
    *   **Назначение файла:** Что делает этот класс/компонент в оригинальном приложении.
    *   **Анализ UI (если применимо):** Описание всех элементов интерфейса, их состояний и событий.
    *   **Анализ логики:** Описание ключевых методов, алгоритмов, используемых переменных и констант.
    *   **Взаимодействие:** Как этот компонент связан с другими частями приложения.
    *   **План портирования:** Конкретные шаги по переносу функциональности на Android, включая выбор подходящих Android-компонентов и архитектурных решений.

### Шаг 2: Написание кода и отслеживание прогресса

**Фраза-триггер:** *"...а после уже приступать к написанию кода с подробным описанием и подробнными сносками используя названия функций, переменных и констант и приблизительной архитектуры и названия папок, в как в ПК версии (из которой мы портируем)"*

**Расшифровка:**

После того как файл анализа создан и утвержден, можно приступать к написанию кода, соблюдая следующие принципы:

1.  **Преемственность названий:**
    *   **Переменные:** `userName` в C# должен стать `userName` в Java/Kotlin.
    *   **Функции/Методы:** `CalculateTotal()` в C# должен стать `calculateTotal()` в Java/Kotlin (с поправкой на конвенцию именования).
    *   **Константы:** `MAX_USERS` в C# должен стать `MAX_USERS` в Java/Kotlin.
2.  **Архитектурное соответствие:**
    *   **Структура папок:** Если в ПК-версии есть папка `Helpers` или `Utils`, следует создать аналогичную структуру в Android-проекте (например, `helpers` или `utils` в соответствующем пакете).
    *   **Архитектурные паттерны:** Если в оригинальном коде используется определенный паттерн (например, Singleton, Factory), следует по возможности воспроизвести его в портированной версии, адаптируя под особенности Android.
3.  **Подробное описание кода:**
    *   При написании кода оставлять комментарии, объясняющие сложные или неочевидные моменты, особенно если реализация на Android сильно отличается от оригинала.
    *   В описании коммитов или в отчетах о проделанной работе давать подробные сноски и объяснения, почему были приняты те или иные решения.

**Отслеживание статуса задач:**

В процессе выполнения задач, описанных в `todo_*.md` файлах, необходимо маркировать их статус. Используйте следующие обозначения:

*   `[x]` - **Выполнено**
*   `[ ]` - **Не выполнено**
*   `[-]` - **Отложено** (если выполнение задачи по какой-то причине блокируется или переносится)

**Пример:**

```markdown
### План реализации

- [x] Создать layout-файл `activity_profile.xml`
- [x] Создать класс `ProfileActivity.java`
- [ ] Реализовать логику сохранения данных
- [-] Реализовать функцию `DetectProxy()` (отложено до реализации сетевого модуля)
```

## Структура файла анализа (`todo_filename.cs.md`)

Файл анализа должен содержать следующие разделы:

### 1. План портирования [ИмяФайла].cs

Краткое описание назначения исходного файла. Например: `Файл AutoLogon.cs реализует диалоговое окно с обратным отсчетом перед автоматическим входом в игру.`

### 2. Функциональность в C#

Подробное описание того, как реализована функциональность в исходном C# коде.

*   **Назначение:** Какую задачу выполняет данный компонент?
*   **UI:** Какие элементы пользовательского интерфейса используются и как они выглядят?
*   **Логика:** Как работает основная логика? Какие классы, методы и события используются? Как обрабатываются пользовательские взаимодействия?
*   **Данные:** Как и где хранятся данные, связанные с этим компонентом?

**Пример для `AutoLogon.cs`:**

*   **Назначение**: Дать пользователю несколько секунд, чтобы отменить автоматический вход в игру. Если пользователь ничего не делает, вход происходит автоматически.
*   **UI**: Окно отображает имя пользователя, для которого выполняется вход, и две кнопки: "Отмена" и кнопка подтверждения (например, "Войти (10)").
*   **Обратный отсчет**: При открытии окна запускается `System.Windows.Forms.Timer`. Каждую секунду он уменьшает счетчик и обновляет текст на кнопке подтверждения, показывая оставшееся время.
*   **Авто-подтверждение**: Когда счетчик доходит до нуля, форма автоматически закрывается с результатом `DialogResult.OK`, что инициирует вход в игру.
*   **Отмена**: Пользователь может нажать кнопку "Отмена", чтобы прервать таймер и отменить автологин.

### 3. Решение для портирования на Android

Описание того, как данная функциональность будет реализована на Android. Какие классы и подходы будут использоваться?

**Пример для `AutoLogon.cs`:**

Эта функциональность легко реализуется с помощью стандартного `AlertDialog` и системного класса `android.os.CountDownTimer`.

### 4. План реализации

Пошаговый план реализации на Android.

1.  **Создание UI:** Описание того, как будет создан пользовательский интерфейс (XML-разметка или программно).
2.  **Реализация логики:** Подробное описание того, как будет реализована логика, включая создание методов, обработчиков событий и т.д.
3.  **Взаимодействие с другими компонентами:** Как новый компонент будет взаимодействовать с другими частями приложения.

**Пример для `AutoLogon.cs`:**

1.  **Создать утилитный метод** для показа диалога, который будет принимать `Context`, имя пользователя и `callback` для обработки результата.
    ```java
    public interface AutoLogonCallback {
        void onLoginConfirmed();
        void onLoginCancelled();
    }

    public static void showAutoLogonDialog(Context context, String userName, AutoLogonCallback callback) { ... }
    ```

2.  **Реализация `showAutoLogonDialog`**:
    *   Создать `AlertDialog.Builder` с заголовком "Автоматический вход" и сообщением, включающим `userName`.
    *   Установить кнопки:
        ```java
        builder.setNegativeButton("Отмена", (dialog, which) -> {
            // Таймер будет остановлен в обработчике onCancel
        });
        builder.setPositiveButton("Войти", (dialog, which) -> {
            // Этот обработчик сработает при нажатии или по окончании таймера
            callback.onLoginConfirmed();
        });
        ```
    *   Создать и показать диалог: `AlertDialog dialog = builder.create(); dialog.show();`

3.  **Настройка `CountDownTimer`**:
    *   После `dialog.show()`, получить ссылку на кнопку подтверждения: `final Button positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE);`
    *   Создать и запустить `CountDownTimer`:
        ```java
        final CountDownTimer timer = new CountDownTimer(10000, 1000) { // 10 секунд
            @Override
            public void onTick(long millisUntilFinished) {
                positiveButton.setText("Войти (" + (millisUntilFinished / 1000) + ")");
            }

            @Override
            public void onFinish() {
                if (dialog.isShowing()) {
                    dialog.dismiss();
                    callback.onLoginConfirmed();
                }
            }
        }.start();
        ```

4.  **Обработка отмены**:
    *   Добавить слушатель отмены/закрытия диалога, в котором будет останавливаться таймер, чтобы избежать утечек и лишних срабатываний.
        ```java
        dialog.setOnCancelListener(dialogInterface -> {
            timer.cancel();
            callback.onLoginCancelled();
        });
        ```

## Принцип Детализации Анализа

**Важное замечание:** При создании `.md` файлов анализа необходимо придерживаться максимальной детализации.

- **Не сокращать логику:** Избегайте чрезмерного обобщения. Вместо "класс управляет настройками" подробно опишите, *какими именно* настройками он управляет, какие у них типы, какие значения по умолчанию, и как они сгруппированы.
- **Сохранять детали реализации:** Указывайте конкретные классы, методы, структуры данных (например, `Dictionary<string, List<int>>`, а не просто "словарь"), используемые в C# коде. Это критически важно для точного воссоздания логики.
- **Цитировать и объяснять:** Если в C# коде есть неочевидные или важные участки (например, сложный алгоритм, специфическая обработка ошибок, работа с битовыми масками), приводите эти участки кода в анализе и давайте подробные объяснения, что они делают и как их следует портировать.
- **План реализации должен быть гранулярным:** Разбивайте план на мелкие, конкретные шаги. Например, вместо "Создать ViewModel" пишите "Создать `MyViewModel.kt`, в нем объявить `LiveData<String>` для имени пользователя и `LiveData<List<Item>>` для списка предметов. Реализовать метод `loadItems()`, который будет обращаться к `ItemsRepository`".

**Основная цель — создать такой `.md` файл, чтобы другой разработчик (или вы сами в будущем) мог, читая только его, полностью понять, как работал исходный компонент и как его реализовать на Android, не заглядывая постоянно в C#-код.** Не удаляйте и не сокращайте информацию, которая кажется вам "маловажной", без явного на то указания.

### Принцип Актуализации Документации

**КРИТИЧЕСКИ ВАЖНО:** Файлы анализа `*.md` являются "живой" документацией. По мере реализации функционала необходимо ОБЯЗАТЕЛЬНО обновлять статусы задач в секции "План реализации".

- **Выполнили шаг -> Поставили `[x]`:** Сразу после успешной реализации и проверки любого пункта из плана (например, "Создать класс `MyClass.java`", "Добавить метод `calculate()`", "Реализовать парсинг XML"), необходимо найти соответствующий пункт в `.md` файле и изменить его маркер с `[ ]` на `[x]`.
- **Не оставлять на потом:** Нельзя сначала реализовать весь класс, а потом обновлять документацию. Обновление должно происходить пошагово, параллельно с написанием кода. Это гарантирует, что статус проекта всегда актуален.

        Обработчик `setNegativeButton` также вызовет `OnCancelListener`.
