
### 1. План портирования MapPath_0103.cs

Файл `MapPath_0103.cs` содержит альтернативную реализацию алгоритма поиска пути. Судя по структуре, это реализация **поиска в ширину (Breadth-First Search, BFS)**.

### 2. Функциональность в C#

- **Назначение:** Найти путь с наименьшим количеством шагов до цели.
- **Логика (`MapPath` конструктор):**
    1.  **Инициализация:** Создает `_matrix` (словарь), куда записывается лучший известный путь до каждой посещенной ячейки.
    2.  **Цикл по итерациям (слоям):** Алгоритм работает по шагам. На шаге `N` он исследует все ячейки, достижимые за `N-1` шагов.
    3.  **Расширение узла:** Для каждой ячейки на текущем "фронте" волны поиска, он находит всех соседей (соседние, врата, телепорты).
    4.  **Обновление матрицы:** Для каждого соседа, он проверяет, был ли он уже достигнут. Если нет, или если новый путь до него лучше (при том же количестве шагов), то информация в `_matrix` обновляется.
    5.  **Завершение:** Цикл останавливается, как только будет найден путь до одной из целевых ячеек. Это гарантирует, что найденный путь будет иметь минимальное количество шагов.

- **Отличие от `MapPath_0101.cs`:**
    - `0101` (Дейкстра/A*) ищет путь с **минимальной стоимостью (cost)**, который может быть длиннее по количеству шагов.
    - `0103` (BFS) ищет путь с **минимальным количеством шагов**, а уже среди таких путей выбирает тот, у которого меньше стоимость.

### 3. Решение для портирования на Android

Рекомендации те же, что и для `MapPath_0101.cs`. Следует использовать стандартную библиотеку для поиска пути.

- **Библиотека JGraphT:** Этот фреймворк поддерживает и поиск в ширину (`BreadthFirstIterator`), и алгоритм Дейкстры, и A*. Можно будет выбрать и сконфигурировать тот алгоритм, который наиболее точно соответствует требуемому поведению.

### 4. План реализации

План реализации идентичен плану для `MapPath_0101.cs`, так как оба файла решают одну и ту же задачу, просто разными алгоритмами. Выбор конкретного алгоритма в `JGraphT` будет зависеть от того, какая из двух реализаций (`0101` или `0103`) в итоге используется в C#-проекте.

1.  **Интегрировать JGraphT:** Добавить библиотеку `JGraphT` в зависимости проекта.
2.  **Создать класс `MapGraph`:** Построить граф карты из данных `MapRepository`.
3.  **Создать класс `Pathfinder`:**
    - Использовать один из алгоритмов `JGraphT` (например, `DijkstraShortestPath` или `AStarShortestPath`) для поиска пути.
    - Выбор и настройка весов ребер и эвристики позволят эмулировать поведение как `0101`, так и `0103`.
4.  **Перенести `MapPath`:** Создать data-класс для хранения результата.

- [ ] Добавить зависимость `JGraphT` в `build.gradle`.
- [ ] Создать класс `MapGraph` для построения графа.
- [ ] Создать класс `Pathfinder`, использующий `JGraphT`.
- [ ] Создать data-класс `MapPath` для хранения результата.
