
### 1. План портирования MapPath_0101.cs

Файл `MapPath_0101.cs` содержит основную реализацию алгоритма поиска пути (pathfinding) на игровой карте. Судя по всему, это вариация алгоритма Дейкстры или A*.

### 2. Функциональность в C#

- **Назначение:** Найти оптимальный путь между двумя точками на карте.
- **Логика (`MapPath` конструктор):**
    1.  **Инициализация:** Начинает поиск с исходной ячейки.
    2.  **Цикл поиска:** В цикле перебирает "открытые" узлы (ячейки для исследования).
    3.  **Расширение узла:** Для каждого узла находит всех соседей, учитывая:
        - **Обычные переходы:** 8 соседних ячеек.
        - **Городские врата:** Жестко закодированные переходы между определенными ячейками (например, "8-259" -> "8-294").
        - **Телепорты:** Если текущая ячейка - телепорт, добавляет в соседи все остальные телепорты.
    4.  **Оценка пути:** Для каждого нового пути к соседу рассчитывается его "стоимость". Алгоритм отбрасывает пути, которые уже дороже, чем лучший найденный на данный момент путь до цели (отсечение/pruning).
    5.  **Завершение:** Когда все пути до цели найдены, выбирается один из самых дешевых (если их несколько) и сохраняется как результат.
- **`CanUseExistingPath()`**: Вспомогательный метод для авто-навигатора. Проверяет, находится ли персонаж на уже рассчитанном пути, и определяет следующий шаг.

### 3. Решение для портирования на Android

Реализовывать такой сложный алгоритм с нуля не рекомендуется. Лучше использовать готовую, протестированную библиотеку для работы с графами и поиска пути.

- **Представление карты:** Карта, загруженная в базу данных Room, должна быть представлена в виде графа, где ячейки - это вершины, а возможные переходы (соседние, врата, телепорты) - это ребра с весами (стоимость перехода).
- **Библиотека для поиска пути:** **JGraphT** - это мощная и популярная open-source библиотека для работы с графами, которая содержит множество готовых алгоритмов, включая A* и Дейкстру. Это идеальный кандидат.

### 4. План реализации

1.  **Интегрировать JGraphT:** Добавить библиотеку `JGraphT` в зависимости проекта.
2.  **Создать класс `MapGraph`:**
    - Этот класс будет отвечать за построение графа из данных, полученных от `MapRepository`.
    - Он создаст `Graph<String, DefaultWeightedEdge>`, где `String` - это `cellNumber`.
    - Он добавит ребра для всех типов переходов с соответствующими весами.
3.  **Создать класс `Pathfinder`:**
    - Будет принимать `MapGraph`, начальную и конечную точки.
    - Использовать `AStarShortestPath<String, DefaultWeightedEdge>(mapGraph)` из JGraphT для поиска пути.
    - Возвращать результат в виде объекта `MapPath`, содержащего список ячеек и общую стоимость.
4.  **Перенести `MapPath`:**
    - Создать data-класс `MapPath`, который будет хранить результат (список ячеек, стоимость).
    - Перенести в него логику метода `canUseExistingPath`.

- [ ] Добавить зависимость `JGraphT` в `build.gradle`.
- [ ] Создать класс `MapGraph` для построения графа на основе данных из `MapRepository`.
- [ ] Создать класс `Pathfinder`, использующий `JGraphT` для поиска пути.
- [ ] Создать data-класс `MapPath` для хранения результата и логики навигации по нему.
