
### 1. План портирования LezFight.cs

Файл `LezFight.cs` — это мозг системы "Автобой". Этот класс отвечает за парсинг HTML-кода страницы боя, принятие решения о следующем действии на основе настроек пользователя и формирование запроса к серверу.

### 2. Функциональность в C#


- **Парсинг:** Класс получает HTML-код страницы и извлекает из него данные, которые находятся внутри JavaScript-массивов (`fight_ty`, `param_ow`, `stand_in` и т.д.). Этот метод парсинга крайне хрупкий и зависит от неизменности верстки страницы.
- **Идентификация:** Определяет параметры игрока (HP, Mana), противника (имя, уровень, тип) и доступные для использования приемы и заклинания.
- **Движок принятия решений:**
    1.  На основе настроек из `LezBotsGroup` определяет, какие действия разрешены.
    2.  Генерирует все возможные комбинации ударов, блоков и заклинаний (`LezNode`).
    3.  Оценивает и сравнивает эти комбинации, чтобы выбрать "наилучшую" (например, по максимальному урону или другой логике).
- **Формирование результата:**
    - `Result`: Создает пайп-разделённую (`|`) строку с параметрами для POST-запроса.
    - `Frame`: Создает целую HTML-страницу со скрытой формой, которая автоматически отправляется через JavaScript. Это способ автоматизировать POST-запрос из `WebBrowser`.

### 3. Решение для портирования на Android

Прямое портирование этого класса нецелесообразно. Необходимо переосмыслить архитектуру, сохранив основную логику принятия решений.

- **Парсинг:** Вместо хрупкого парсинга строк в Kotlin, следует использовать `JavascriptInterface`. В `WebView` внедряется JavaScript-код, который собирает все нужные данные со страницы в единый JSON-объект и передает его в нативный код. Это намного чище и проще в поддержке.
- **Движок решений:** Основную логику генерации и оценки комбинаций (`LezNode` и вложенные циклы) можно портировать на Kotlin. **Критически важно** вынести эти вычисления в фоновый поток (с помощью Kotlin Coroutines), чтобы не блокировать UI.
- **Выполнение действий:** Вместо генерации HTML-фрейма, Android-приложение должно напрямую выполнять POST-запрос к серверу, используя современный HTTP-клиент (например, `OkHttp` или `Retrofit`). Параметры для запроса будут взяты из "наилучшей" комбинации, найденной движком.
- **Управление состоянием:** Весь процесс должен управляться конечным автоматом (State Machine) со состояниями `IDLE`, `FIGHTING`, `WAITING`, `ENDED`. Этим может заниматься `ViewModel`.

### 4. План реализации

1.  **Фаза 1: Извлечение данных.**
    - [ ] Создать `data class FightState` в Kotlin, который будет представлять все данные, извлекаемые со страницы боя (HP, мана, противник, доступные абилки и т.д.).
    - [ ] Создать `JavascriptInterface` с методом `processFightHtml(json: String)`.
    - [ ] Написать JavaScript-код, который будет собирать все переменные (`fight_ty`, `param_ow` и др.) в JSON и вызывать `processFightHtml`.
    - [ ] Внедрять и вызывать этот JS-код в `WebViewClient.onPageFinished`.
2.  **Фаза 2: Движок принятия решений.**
    - [ ] Создать класс `FightDecisionEngine`, работающий в фоновом потоке (`CoroutineScope(Dispatchers.Default)`).
    - [ ] Портировать логику из `LezFight.cs` и `LezNode.cs` по генерации и оценке комбинаций действий.
    - [ ] На вход движок получает объект `FightState`, на выходе отдает объект `ChosenAction`, описывающий, что нужно сделать.
3.  **Фаза 3: Выполнение действий.**
    - [ ] Создать `FightActionExecutor` (часть репозитория или `ViewModel`).
    - [ ] Этот класс будет принимать `ChosenAction` и формировать на его основе HTTP POST-запрос к серверу `neverlands.ru` с помощью `OkHttp`.
4.  **Фаза 4: Управление состоянием.**
    - [ ] Создать `FightViewModel`.
    - [ ] `ViewModel` будет получать данные от `JavascriptInterface`, передавать их в `FightDecisionEngine`, получать результат, отправлять его в `FightActionExecutor` и обновлять `LiveData` с текущим состоянием автобоя.

- [ ] Реализовать `JavascriptInterface` для сбора данных из `WebView`.
- [ ] Портировать `LezNode` и логику комбинаций в `FightDecisionEngine`.
- [ ] Реализовать выполнение POST-запросов через `OkHttp`.
- [ ] Создать `FightViewModel` для оркестрации всего процесса.
