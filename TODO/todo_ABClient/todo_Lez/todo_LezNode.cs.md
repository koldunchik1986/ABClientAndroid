
### 1. План портирования LezNode.cs - [+] Реализован в LezNode.java

Файл `LezNode.cs` — это ключевая структура данных для движка принятия решений в `LezFight`. Экземпляр этого класса представляет собой одно полное действие (ход) в бою, состоящее из комбинации ударов, блока и магии.

### 2. Функциональность в C#

- **Назначение:** Представлять и оценивать возможный ход в бою.
- **Структура:** Хранит массивы кодов и операций для ударов, блока и магических заклинаний, которые составляют один ход.
- **`IComparable` и `Z()`-оценка:**
    - Самая важная часть класса — реализация `IComparable`.
    - Сравнение двух `LezNode` происходит через сравнение строк, сгенерированных методом `Z()`.
    - Метод `Z()` создает строку-оценку (например, `"0.2.04.1.25"`), которая является эвристической оценкой "ценности" хода. Каждый сегмент строки представляет ценность определенного аспекта хода (использование свитков, восстановление HP/маны, магия, блок, удары).
    - Сравнивая эти строки, `LezFight` может отсортировать возможные ходы и выбрать лучший по заранее определенной стратегии (например, ход с восстановлением HP будет "больше", чем ход с простой атакой).
- **`ICloneable`:** Класс поддерживает глубокое клонирование, что позволяет `LezFight` итеративно строить сложные комбинации ходов.
- **Вспомогательные методы:** `Od()` и `Mana()` для подсчета затрат очков действия и маны.

### 3. Решение для портирования на Android

Этот класс содержит чистую логику и должен быть портирован на Kotlin как можно точнее, чтобы сохранить поведение "ИИ" автобоя. Он станет основной частью `FightDecisionEngine`, описанного в анализе `LezFight.cs`.

### 4. План реализации

1.  **Создать класс `LezNode.kt`:**
    - Создать обычный (не `data`) класс `LezNode` в Kotlin.
    - Портировать все поля. Массивы (`int[]`, `bool[]`) можно оставить как есть (`IntArray`, `BooleanArray`).
    - Класс должен реализовывать `Cloneable` и `Comparable<LezNode>`.
2.  **Портировать логику методов:**
    - **`compareTo` и `z()`:** Тщательно перенести логику генерации Z-строки и ее сравнения. Это ядро эвристики.
    - **`od()` и `mana()`:** Перенести логику подсчета затрат.
    - **`addHit()`, `addBlock()`, `addMagic()`:** Перенести методы для построения хода.
3.  **Реализовать `clone()`:**
    - Реализовать метод `clone()`, который будет выполнять глубокое копирование объекта. Это означает создание нового экземпляра `LezNode` и копирование в него всех полей, включая создание новых экземпляров для всех массивов.
4.  **Интеграция:**
    - Этот класс будет использоваться в `FightDecisionEngine` для создания, комбинирования и оценки всех возможных ходов в текущем раунде боя.

- [ ] Создать класс `LezNode` в Kotlin, реализующий `Cloneable` и `Comparable`.
- [ ] Тщательно портировать логику эвристической оценки `Z()`.
- [ ] Реализовать функцию глубокого клонирования.
- [ ] Портировать все вспомогательные методы (`od`, `mana` и т.д.).
