# План портирования RoomManager.cs

Файл `RoomManager.cs` представляет собой статический класс, который в фоновом режиме отслеживает изменения в игровой комнате (локации), обрабатывает полученные данные и модифицирует отображение для пользователя.

## Функциональность в C#

*   **Назначение**: Основная задача - периодически запрашивать данные о текущей комнате (`ch.php`), сравнивать их с предыдущим состоянием и на основе этого выполнять различные действия: обновлять UI, выводить сообщения о вошедших/вышедших игроках, инициировать автоматические действия.
*   **Фоновая работа**: Для периодических запросов используется отдельный поток (`Thread`), который синхронизируется с помощью `AutoResetEvent`.
*   **Сетевые запросы**: Выполняет GET-запросы к `http://neverlands.ru/ch.php?lo=1&` с использованием `HttpWebRequest` и передачей cookies.
*   **Парсинг HTML**: 
    *   Извлекает список игроков и их данные (ник, уровень, клан, травмы и т.д.) из HTML-ответа.
    *   Определяет название текущей локации.
    *   Считает количество невидимых игроков.
*   **Модификация HTML**: 
    *   Внедряет в полученный HTML-код дополнительный CSS для стилизации ников и иконок.
    *   Внедряет JavaScript для добавления выпадающего списка быстрой навигации.
    *   Добавляет информацию о невидимых игроках и кнопку для их обнаружения.
*   **Управление игроками**:
    *   `MyLocation`: Хранит список ников игроков в текущей локации.
    *   `BlackList`: Временный черный список для игроков, чтобы избежать повторных автоматических действий.
    *   `FilterGetWalkers`: Сравнивает текущий список игроков с предыдущим, чтобы определить, кто вошел или вышел, и формирует соответствующие сообщения для чата.
*   **Автоматические действия**:
    *   `AutoOpenNevid`: Автоматическое использование свитка обнаружения, если в локации есть невидимые игроки.
    *   `AutoAttack`: Автоматическое нападение на врагов из списка контактов.
*   **Взаимодействие с UI**: 
    *   Использует `BeginInvoke` для безопасного обновления UI из фонового потока.
    *   Вызывает методы `FormMain` для обновления чата (`UpdateChat`), списков игроков и травмированных (`UpdateRoom`).

## Решение для портирования на Android

Эта функциональность будет реализована в виде `Service` или с использованием `ViewModel` и `Coroutine` для фоновых задач. Модификация HTML будет происходить в `WebViewClient` или с помощью JavaScript-интерфейса.

## План реализации

### Шаг 1: Проверка на существующую реализацию

- [ ] Проверить, существует ли уже сервис или фоновая задача, которая выполняет похожие функции. Судя по `ProxyService`, некоторая сетевая логика уже есть, но она связана с прокси. `RoomManager` реализует активный поллинг, что является новой функциональностью.

### Шаг 2: Создание фоновой службы

- [ ] Создать `RoomManager.java` как синглтон или статический класс.
- [ ] Вместо `Thread` использовать `kotlinx.coroutines.CoroutineScope` для запуска фоновой задачи, которая будет циклически выполняться.
- [ ] Вместо `AutoResetEvent` использовать `delay()` для создания паузы между запросами.

### Шаг 3: Реализация сетевых запросов

- [ ] Использовать `OkHttp` или `Retrofit` (которые уже есть в проекте) для выполнения GET-запросов к `ch.php`.
- [ ] Реализовать передачу cookies, используя существующий `CookiesManager`.

### Шаг 4: Парсинг и обработка данных

- [ ] Создать методы для парсинга HTML. Вместо `HelperStrings.SubString` можно использовать регулярные выражения (`java.util.regex.Pattern`) или библиотеку для парсинга HTML, такую как `Jsoup` (если ее добавление оправдано).
- [ ] Реализовать логику `FilterProcRoom` и `FilterGetWalkers` для извлечения данных об игроках и отслеживания перемещений.
- [ ] Сохранить `BlackList` и `MyLocation` в виде `List` или `Map`.

### Шаг 5: Модификация HTML и взаимодействие с WebView

- [ ] Логику модификации HTML (`Process`) перенести в метод, который будет вызываться из `WebViewClient`'s `shouldInterceptRequest` или `onPageFinished`.
- [ ] В `shouldInterceptRequest` можно перехватить ответ от `ch.php`, модифицировать его и вернуть новый `WebResourceResponse`.
- [ ] В качестве альтернативы, можно в `onPageFinished` внедрять JavaScript через `webView.evaluateJavascript()` для динамического изменения DOM-дерева страницы.
- [ ] Создать JavaScript-интерфейс (`@JavascriptInterface`) для связи между `WebView` и нативным кодом (например, для вызова `FastAttackOpenNevid()`).

### Шаг 6: Взаимодействие с UI

- [ ] Вместо `BeginInvoke` использовать `LiveData` или `SharedFlow`/`StateFlow` в `ViewModel` для уведомления `Activity`/`Fragment` об изменениях.
- [ ] `MainActivity` будет подписываться на эти `LiveData`/`Flow` и обновлять соответствующие элементы UI (чат, списки игроков).

### План реализации (детальный)

- [ ] **Создать `RoomManager.java`**
    - [ ] `startTracing()`: Запускает корутину для фоновой работы.
    - [ ] `stopTracing()`: Останавливает корутину.
    - [ ] `roomAsync()`: Основной метод в корутине, который выполняет цикл запросов.
- [ ] **Реализовать `process(html)`**
    - [ ] `filterProcRoom(html)`: Парсит игроков и их данные.
    - [ ] `filterGetWalkers(html)`: Определяет вошедших/вышедших.
    - [ ] Добавить JS и CSS в HTML.
- [ ] **Интеграция с `WebView`**
    - [ ] В `MainActivity` или соответствующем `Fragment`'е, в `WebViewClient`, перехватывать загрузку `ch.php`.
    - [ ] Вызывать `RoomManager.process(html)` для модификации контента.
- [ ] **Обновление UI**
    - [ ] Создать `ViewModel` (`MainViewModel`).
    - [ ] В `RoomManager`'е вызывать методы `ViewModel`'а для обновления `LiveData`.
    - [ ] В `MainActivity` подписаться на `LiveData` и обновлять UI.