# План портирования Crypts.cs

Файл `Crypts.cs` - это статический класс, реализующий всю криптографическую логику приложения.

## Функциональность в C#

*   **Назначение**: Шифрование и дешифрование данных профиля, а также хеширование паролей для проверки.
*   **Шифрование**: 
    *   Используется симметричный алгоритм `TripleDES`.
    *   Ключ и вектор инициализации (IV) генерируются из пароля пользователя и жестко закодированной соли (`AppConsts.SaltBinary`) с помощью `Rfc2898DeriveBytes` (реализация PBKDF2).
*   **Хеширование**: 
    *   Метод `Password2Hash` использует алгоритм `MD5`.
    *   Перед хешированием к паролю добавляется другая жестко закодированная соль (`AppConsts.SaltText`).
    *   Результат возвращается в виде строки Base64.

## Проверка на существующую реализацию в Android

- **Результат:** Функциональность не реализована. В Android-проекте нет криптографического класса `Crypts`.

## Решение для портирования на Android

Необходимо в точности воспроизвести все криптографические операции, используя стандартные Java-библиотеки `javax.crypto` и `java.security`. Любое отклонение в алгоритме, солях, длине ключа или методе его генерации приведет к несовместимости с зашифрованными данными из ПК-версии.

## План реализации

- [ ] **Создать файл `Crypts.java`** в пакете `ru.neverlands.abclient.utils`.

- [ ] **Портировать `password2Hash(String password)`**:
    - [ ] Создать статический метод.
    - [ ] Получить байты из `AppConsts.SALT_TEXT + password`.
    - [ ] Использовать `java.security.MessageDigest.getInstance("MD5")` для вычисления хеша.
    - [ ] Закодировать результат в Base64 с помощью `android.util.Base64`.

- [ ] **Портировать `encryptString` / `decryptString`**:
    - [ ] Создать соответствующие статические методы.
    - [ ] Они будут вызывать `encryptData` / `decryptData` и обрабатывать кодировку и Base64.

- [ ] **Портировать `encryptData` / `decryptData`**:
    - [ ] **Генерация ключа**: Вместо `Rfc2898DeriveBytes` использовать `javax.crypto.spec.PBEKeySpec` и `javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1")`.
    - [ ] **Шифрование**: Использовать `javax.crypto.Cipher.getInstance("DESede/CBC/PKCS5Padding")`.
    - [ ] **Ключ и IV**: Из сгенерированного `SecretKeyFactory` нужно будет получить ключ и IV нужной длины (16 байт для ключа, 8 для IV в C# `TripleDES`). Важно убедиться, что длины и способ получения соответствуют реализации в C#.
    - [ ] `Cipher` нужно будет инициализировать с `SecretKeySpec` (для ключа) и `IvParameterSpec` (для вектора инициализации).

- [ ] **Валидация**: После реализации необходимо будет создать тестовый набор (зашифрованная строка и пароль из C#-версии) и убедиться, что Java-реализация успешно его расшифровывает.

- [ ] **Обновить `todo_Helpers.md`**, отметив `Crypts.cs` как проанализированный.
