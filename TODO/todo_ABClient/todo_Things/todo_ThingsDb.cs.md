
### 1. План портирования ThingsDb.cs

Файл `ThingsDb.cs` — это статический класс, который выступает в роли менеджера базы данных игровых предметов. Он отвечает за загрузку данных из `abthings.xml` и их обработку.

### 2. Функциональность в C#

- **Назначение:** Загружать и предоставлять доступ к базе данных вещей.
- **Реализация:**
    - `static class`: Работает как синглтон.
    - `Load()`: При запуске читает `abthings.xml` с помощью `XmlReader` и загружает все предметы в статический `List<Thing>` в памяти.
    - `Find()`: Ищет в этом списке все вещи с указанным изображением.
    - `FindPart()`: Сложный метод, который находит конкретную вещь, сравнивает ее характеристики и генерирует HTML-строки (`StrReq`, `StrBon`) для отображения во всплывающей подсказке.

### 3. Решение для портирования на Android

Статический менеджер с загрузкой всего в память и смешиванием логики данных с логикой представления (генерация HTML) — это устаревший подход. Необходимо использовать современную архитектуру с разделением ответственности.

- **Архитектура:** Паттерн "Репозиторий" + Room.
    - **Репозиторий:** `ThingsRepository` будет единственным источником данных о вещах.
    - **База данных:** Данные будут храниться в базе данных Room для эффективного доступа, а не в списке в памяти.
    - **ViewModel:** Логика сравнения и подготовки данных для отображения должна быть вынесена из репозитория в `ViewModel`.

### 4. План реализации

1.  **Создать `ThingDao.kt` (Data Access Object):**
    - Создать интерфейс, аннотированный `@Dao` для Room.
    - Определить в нем методы для доступа к данным.
      ```kotlin
      @Dao
      interface ThingDao {
          @Query("SELECT * FROM things WHERE image = :image")
          suspend fun findByImage(image: String): List<Thing>

          @Insert(onConflict = OnConflictStrategy.REPLACE)
          suspend fun insertAll(things: List<Thing>)

          @Query("SELECT COUNT(*) FROM things")
          suspend fun getCount(): Int
      }
      ```
2.  **Создать `ThingsRepository.kt`:**
    - Создать синглтон-класс `ThingsRepository`.
    - В нем реализовать метод `populateDatabaseIfNeeded()`, который:
        - При первом запуске проверяет `ThingDao.getCount()`.
        - Если база пуста, читает `abthings.xml` из папки `assets` с помощью `XmlPullParser`.
        - Парсит XML, создает список объектов `Thing` и вставляет их в БД через `ThingDao.insertAll()`.
    - Реализовать публичные методы, например, `suspend fun findByImage(image: String)`, которые просто вызывают соответствующие методы DAO.
3.  **Вынести логику `FindPart` в `ViewModel`:**
    - Создать `ViewModel`, например, `ItemTooltipViewModel`.
    - Этот `ViewModel` будет получать от репозитория нужные объекты `Thing`.
    - В `ViewModel` перенести логику сравнения предметов из `FindPart`.
    - `ViewModel` будет подготавливать для UI не готовую HTML-строку, а модель данных, удобную для отображения (например, `data class DisplayableStat(val name: String, val value: String, val isBetter: Boolean)`).

- [ ] Создать `ThingDao` для Room.
- [ ] Создать `ThingsRepository`.
- [ ] Реализовать в репозитории логику однократной загрузки данных из `abthings.xml` в Room.
- [ ] Перенести логику сравнения из `FindPart` в соответствующий `ViewModel`.
