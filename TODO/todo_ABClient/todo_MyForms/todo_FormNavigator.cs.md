
### 1. План портирования FormNavigator.cs

Файл `FormNavigator.cs` реализует основное окно навигатора. Это сложная форма, которая объединяет отображение карты, поиск пути, иерархический список локаций и запуск авто-навигации.

### 2. Функциональность в C#

- **UI:**
    - `browserMap`: `WebBrowser` для отображения интерактивной HTML/JS карты.
    - `treeDest`: `TreeView` для отображения древовидного списка возможных пунктов назначения (избранное, города, боты, травы и т.д.).
    - `textDest`: Поле для ручного ввода или поиска локации.
    - Метки для отображения информации о пути (длина, уровень ботов).
- **Логика:**
    - **Инициализация:** При запуске формы, она загружает все данные о карте из статического класса `Map`, строит списки ботов и трав, и заполняет `TreeView` (`PopulateStandardList`).
    - **JS Bridge:** Создает `NavScriptManager` и передает его в `WebBrowser`, делая C#-методы доступными для Javascript карты.
    - **Поиск пути (`PointToDest`)**: Центральный метод. При выборе цели (в дереве или вручную), он создает экземпляр `MapPath` для расчета пути. Если путь найден, обновляет информационные метки и вызывает `UpdateMap`.
    - **Отображение карты (`UpdateMap`)**: Генерирует с нуля HTML-страницу, в которую встроен JS-код карты (`mapnav.js`), и загружает ее в `WebBrowser`, центрируя на нужной локации.
    - **Запуск навигации (`buttonOk_Click`)**: Устанавливает глобальные переменные `AppVars.AutoMovingDestinaton` и `AppVars.AutoMoving`, запуская тем самым процесс авто-перемещения по карте.

### 3. Решение для портирования на Android

Эта форма требует полного архитектурного и UI-переосмысления для Android. Вместо `WebBrowser` и `TreeView` следует использовать нативные компоненты и паттерн MVVM.

1.  **UI (`Activity` или `Fragment`):**
    - Вместо `TreeView` использовать `RecyclerView`. Для создания иерархического списка можно использовать готовую библиотеку или реализовать адаптер с несколькими `ViewType`.
    - Вместо `WebBrowser` использовать кастомную `MapView`, как было описано в анализе `Map.cs`.
2.  **ViewModel (`NavigatorViewModel`):**
    - Будет содержать всю логику и состояние экрана.
    - Будет работать с `MapRepository` для получения данных о локациях и с `Pathfinder` для расчета путей.
    - Будет предоставлять `LiveData` для списка локаций, текущего пути и другой информации для отображения в UI.

### 4. План реализации

Поскольку в Android-коде нет ничего из этой логики, план описывает создание с нуля.

1.  **Создать `NavigatorActivity` и его XML-разметку:**
    - Разместить `RecyclerView` для списка локаций, кастомную `MapView` и другие необходимые `View`.
2.  **Создать `NavigatorViewModel`:**
    - Реализовать в нем методы для загрузки данных для списка (`loadDestinationTree()`). Этот метод будет запрашивать данные у `MapRepository` и формировать иерархическую структуру.
    - Реализовать метод `calculatePath(destination: String)`, который будет использовать `Pathfinder` и обновлять `LiveData<MapPath>`.
3.  **Создать адаптер для `RecyclerView`:**
    - Адаптер должен уметь отображать как группы (например, "Боты", "Травы"), так и конечные локации.
    - По клику на элемент списка, адаптер должен вызывать метод в `ViewModel` для расчета пути.
4.  **Связать UI и ViewModel:**
    - `Activity` подписывается на `LiveData` из `ViewModel`.
    - При изменении `LiveData<MapPath>`, `Activity` передает новый путь в `MapView` для отрисовки и обновляет текстовые поля с информацией о пути.
    - Кнопка "OK" в `Activity` будет вызывать метод в `ViewModel`, который, в свою очередь, запустит сервис авто-навигации.

- [ ] Создать `NavigatorActivity` и ее разметку.
- [ ] Создать `NavigatorViewModel`.
- [ ] Реализовать в `ViewModel` загрузку и построение иерархического списка локаций.
- [ ] Реализовать в `ViewModel` вызов `Pathfinder` и обновление `LiveData` с результатом.
- [ ] Создать сложный адаптер для `RecyclerView`, поддерживающий группы.
- [ ] Связать все компоненты в `Activity` с помощью `LiveData` и `View Binding`.
