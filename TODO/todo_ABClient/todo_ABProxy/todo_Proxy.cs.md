
### 1. План портирования Proxy.cs

Файл `Proxy.cs` содержит основной класс, который запускает и управляет жизненным циклом локального прокси-сервера.

### 2. Функциональность в C#

- **Назначение:** Создать TCP-слушателя на локальном порту, принимать входящие HTTP-запросы и передавать их на обработку.
- **Логика:**
    - **`Start()`**: Основной метод.
        1.  Находит свободный порт, начиная с 8052, и создает `Socket` для прослушивания (`_socketAcceptor`).
        2.  Если в настройках указан вышестоящий (upstream) прокси, настраивает его.
        3.  Вызывает `_socketAcceptor.BeginAccept()` для асинхронного ожидания входящих соединений.
        4.  **Ключевой момент:** Вызывает `SetProxy()`, который через P/Invoke (`InternetSetOption`) устанавливает системные настройки прокси в Windows, чтобы весь трафик браузера пошел через этот локальный прокси.
    - **`AcceptConnection()`**: Callback-метод для `BeginAccept`. Когда клиент подключается, он создает для него новый объект `Session` и передает ему сокет клиента для дальнейшей обработки в отдельном потоке из `ThreadPool`.

### 3. Решение для портирования на Android

Полная эмуляция этого класса, особенно части с `SetProxy`, очень сложна и, скорее всего, не нужна.

- **Прокси только для `WebView`:** Если цель - перехватывать трафик только от `WebView` внутри приложения, то создавать `ServerSocket` и устанавливать системный прокси не нужно. Вместо этого используется `WebViewClient.shouldInterceptRequest`.
- **Системный прокси:** Если цель - перехватывать трафик от других приложений, необходимо использовать `VpnService`. Это очень сложная функциональность, требующая глубоких знаний сетевого стека Android и обработки разрешений от пользователя.

Учитывая контекст приложения, наиболее вероятный и правильный путь - это перехват трафика только от `WebView`.

### 4. План реализации (для `WebView`)

1.  **Не портировать класс `Proxy`:** Этот класс не нужен.
2.  **Создать кастомный `WebViewClient`:**
    - Унаследовать от `android.webkit.WebViewClient`.
3.  **Переопределить `shouldInterceptRequest`:**
    - `public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request)`.
    - Внутри этого метода будет вся логика, которая в C#-версии находится в классе `Session`.
    - Мы получаем готовый объект `request`, из которого можно взять URL, метод, заголовки.
    - Мы выполняем запрос к серверу (например, с помощью `OkHttp`).
    - Получаем ответ от сервера.
    - **Применяем фильтры:** Здесь будет вызываться логика, аналогичная `PostFilter`, для модификации ответа.
    - Создаем и возвращаем `WebResourceResponse` с (возможно, модифицированными) данными.

- [ ] Отказаться от идеи портирования класса `Proxy`.
- [ ] Создать кастомный `WebViewClient`.
- [ ] Реализовать основную логику перехвата и модификации трафика внутри метода `shouldInterceptRequest`.
