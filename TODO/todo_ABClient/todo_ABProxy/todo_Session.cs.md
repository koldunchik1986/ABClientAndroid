
### 1. План портирования Session.cs

Файл `Session.cs` является ядром всей прокси-логики. Экземпляр этого класса представляет одну полную транзакцию (запрос-ответ) и управляет всем процессом от получения запроса от клиента до отправки ему ответа.

### 2. Функциональность в C#

- **Назначение:** Обработать один HTTP-запрос.
- **Логика (`Execute`):**
    1.  **Чтение запроса:** Использует `ClientChatter` для чтения и парсинга запроса от клиента.
    2.  **Манипуляции с запросом:**
        *   Блокирует запросы к трекерам (`top.list.ru`).
        *   Удаляет заголовки кэширования (`If-Modified-Since`) для игровых ресурсов.
        *   Заменяет cookie от клиента на cookie из `CookiesManager`.
    3.  **Проверка кэша:** Проверяет, нет ли запрошенного ресурса в `Cache`. Если есть, немедленно возвращает его.
    4.  **Запрос к серверу:** Если ресурса в кэше нет, использует `ServerChatter` для отправки запроса на удаленный сервер.
    5.  **Чтение ответа:** Использует `ServerChatter` для чтения и парсинга ответа от сервера.
    6.  **Декодирование:** Вызывает `UtilDecodeResponse` для распаковки GZIP/Deflate и обработки chunked-кодирования.
    7.  **Манипуляции с ответом:**
        *   Извлекает время сервера из заголовка `Date`.
        *   Парсит и сохраняет `Set-Cookie` с помощью `CookiesManager`.
        *   **Вызывает `Filter.Process` для применения всех игровых фильтров и модификаций к телу ответа.**
    8.  **Отправка ответа:** Отправляет финальный, модифицированный ответ клиенту.
    9.  **Управление соединением:** Реализует логику `Keep-Alive` для повторного использования сокетов.

### 3. Решение для портирования на Android

Вся логика этого класса должна быть перенесена внутрь метода `WebViewClient.shouldInterceptRequest`. Это полностью меняет подход и избавляет от необходимости вручную управлять сокетами и парсить HTTP.

### 4. План реализации

1.  **Не портировать класс:** Класс `Session` не портируется.
2.  **Реализовать всю логику в `shouldInterceptRequest`:**
    - **Входные данные:** `WebResourceRequest request`.
    - **Шаг 1: Манипуляции с запросом.** Проверить URL и заголовки из `request`. Заблокировать трекеры, вернув пустой ответ. Сформировать новые заголовки (например, `Cookie`).
    - **Шаг 2: Проверка кэша.** Реализовать проверку в собственном кэше (`ProxyCacheManager`). Если есть, вернуть `WebResourceResponse` из кэша.
    - **Шаг 3: Запрос к серверу.** Использовать `OkHttp` для выполнения запроса. URL, метод и заголовки взять из `request`.
    - **Шаг 4: Манипуляции с ответом.** Получить `okhttp3.Response`. Извлечь из него тело ответа, заголовки, код статуса.
    - **Шаг 5: Фильтрация.** Передать тело ответа в новый класс `FilterManager`, который будет содержать логику всех фильтров из папки `PostFilter`.
    - **Шаг 6: Возврат ответа.** Создать `WebResourceResponse` с модифицированным телом, заголовками и статусом и вернуть его.

- [ ] Создать кастомный `WebViewClient`.
- [ ] Реализовать в `shouldInterceptRequest` полный цикл обработки запроса, как описано выше.
- [ ] Создать `FilterManager` для применения игровых модификаций.
