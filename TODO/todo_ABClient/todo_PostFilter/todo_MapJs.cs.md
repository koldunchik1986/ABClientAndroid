### 1. План портирования MapJs.cs

Файл `MapJs.cs` является фильтром для скрипта `map.js`, который отвечает за отображение игровой карты.

### 2. Функциональность в C#

- **Назначение:** Заменить стандартный `map.js` от сервера на кастомную, модифицированную версию, находящуюся в ресурсах клиента.
- **Логика:** Код предельно прост: `return AppVars.Codepage.GetBytes(Resources.map);`. Он полностью игнорирует входящий массив байт (`array`) и вместо него возвращает содержимое файла `ABClient/Js/map.js`, который был скомпилирован в ресурсы приложения.
- **Закомментированный код:** Старый код показывает, что изначально планировалось модифицировать скрипт "на лету", внедряя вызовы `window.external` для получения размеров карты из C#-кода. Однако от этого подхода отказались в пользу полной замены файла.

### 3. Решение для портирования на Android

Необходимо воспроизвести поведение полной замены файла. Файл `map.js` уже присутствует в `assets` Android-проекта.

- **Архитектура:** Фильтр `MapJs.java` должен будет читать локальный файл `js/map.js` из `assets` и возвращать его содержимое вместо данных, полученных от сервера.

### 4. План реализации

1.  **Создать `MapJs.java`:**
    - [x] Создать класс `MapJs` в пакете `ru.neverlands.abclient.postfilter`.
2.  **Реализовать метод `process(byte[] array)`:**
    - [x] Внутри метода, полностью проигнорировать входящий `array`.
    - [x] Открыть и прочитать файл `js/map.js` из `assets`.
        ```java
        try (InputStream is = AppVars.getAssetManager().open("js/map.js")) {
            return DataManager.readAllBytes(is);
        } catch (IOException e) {
            // В случае ошибки, вернуть оригинальный массив, чтобы не сломать игру
            return array;
        }
        ```
    - [x] Использовать существующие `AppVars.getAssetManager()` и `DataManager.readAllBytes()` для чтения файла.
3.  **Обновить `todo_PostFilter.md`:**
    - [x] Пометить `MapJs.cs` как `[x]` проанализированный.

- [x] Реализовать класс `MapJs.java` с логикой подмены файла из `assets`.