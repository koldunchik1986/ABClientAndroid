### 1. План портирования MainPhp.cs (и всех его partial-частей)

Файлы `MainPhp*.cs` представляют собой один большой `partial class` `Filter`, который является самым главным и сложным фильтром в приложении. Он обрабатывает основную игровую страницу `main.php`, которая содержит практически всю информацию о состоянии игры: инвентарь, состояние персонажа, бой, карта, доступные действия и т.д.

### 2. Функциональность в C#

Этот фильтр представляет собой сложный конечный автомат, который в зависимости от глобальных флагов (`AppVars`) и содержимого страницы `main.php` принимает решение о следующем действии.

- **`MainPhp.cs` (основной файл):**
    - **Точка входа:** Метод `MainPhp(address, array)`.
    - **Парсинг:** Извлекает из HTML-кода ключевую информацию: системные сообщения, информацию о нападении (`UnderAttack`), наличие ядов и травм, список одетых комплектов, результат воровства.
    - **Маршрутизация:** Содержит основную логику `if-else if` и `goto end`, которая определяет, какой из под-модулей должен быть активирован. Например, если в HTML есть `magic_slots();`, управление передается в `MainPhpFight(html)`.
    - **Триггеры действий:** На основе глобальных флагов (`AppVars.Profile.DoRob`, `AppVars.Profile.SkinAuto`, `AppVars.FastNeed`, `AppVars.AutoMoving` и т.д.) инициирует различные действия (воровство, разделка, быстрое использование предметов, навигация).
    - **Модификация HTML:** Вставляет в страницу различные элементы, например, информацию об онлайн-пользователях и таймеры HP/MA.

- **`MainPhpAutoCure.cs`:**
    - **`GetPoisonAndWounds`:** Парсит JS-массив `cureff` для определения наличия травм и отравлений.
    - **`MainPhpRemovePoison`:** Если обнаружено отравление и включено автолечение, находит в инвентаре "Зелье Лечения Отравлений" и генерирует редирект для его использования.

- **`MainPhpCure.cs`:**
    - **`MainPhpCure`:** Логика для лечения травм других игроков. Находит в инвентаре нужную аптечку и генерирует редирект для ее использования на цели (`AppVars.CureNick`).

- **`MainPhpFast.cs` и другие `MainPhp*`:**
    - Реализуют логику "быстрых действий" (нападения, использование свитков, зелий).
    - Каждый метод (например, `MainPhpFastTeleport`, `MainPhpFastHit`) ищет в инвентаре нужный предмет (свиток, зелье) и парсит его JS-функцию (`w28_form`, `magicreform`, `abil_svitok`).
    - Затем он генерирует HTML-страницу с авто-сабмитом формы, которая эмулирует использование этого предмета на указанную цель (`AppVars.FastNick`).

- **`MainPhpInv.cs`:**
    - **`MainPhpInv`:** Очень важный фильтр. Парсит инвентарь, группирует одинаковые предметы, добавляет кастомные кнопки ("Продать все", "Выбросить все") и перестраивает HTML-код инвентаря.
    - **Зависимость:** Сильно зависит от класса `InvEntry`, который парсит одну запись в инвентаре.

- **`MainPhpFight.cs`:**
    - **`MainPhpFight`:** Обрабатывает страницу боя. Создает экземпляр `LezFight`, который выполняет всю логику автобоя. Если автобой включен и нет сдерживающих факторов (мало HP/MP), возвращает HTML-фрейм с авто-сабмитом хода.

### 3. Решение для портирования на Android

Прямое портирование этого гигантского набора функций в один Java-класс недопустимо. Необходимо полностью переработать архитектуру, разделив логику на независимые компоненты, управляемые через `ViewModel`.

- **Основной принцип:** Фильтр `MainPhp.java` должен заниматься **только извлечением данных** из HTML. Всю логику принятия решений и выполнения действий должны брать на себя другие классы (`ViewModel`, `Repository`, `Service`).
- **Извлечение данных:** Вместо десятков вызовов `HelperStrings.SubString`, следует использовать `Jsoup` для надежного парсинга HTML и извлечения данных в структурированные `data class`'ы (например, `MainPageData`, `InventoryData`, `FightData`).
- **Управление состоянием:** Все глобальные флаги из `AppVars` (например, `FastNeed`, `AutoMoving`, `CureNeed`) должны стать `LiveData` в соответствующих `ViewModel`'ах.

### 4. План реализации

1.  **Создать `MainPhp.java`:**
    - [ ] Метод `process(address, array)` будет основной точкой входа.
2.  **Реализовать парсинг в `MainPageRepository.kt`:**
    - [ ] Создать `suspend fun parseMainPage(html: String): MainPageData`.
    - [ ] `MainPageData` будет `data class`, содержащий всю информацию со страницы: `UserInfo`, `Inventory`, `FightState`, `LocationInfo` и т.д.
    - [ ] Использовать `Jsoup` для парсинга HTML и извлечения JS-переменных (`var params`, `var cureff`, `var slots` и т.д.).
3.  **Создать `MainViewModel.kt`:**
    - [ ] Будет хранить `LiveData` с состоянием игры (`mainPageData`).
    - [ ] Метод `processPage(html: String)` будет вызывать `MainPageRepository.parseMainPage` в корутине.
    - [ ] На основе полученных `MainPageData`, `ViewModel` будет принимать решения и вызывать другие сервисы/репозитории:
        - Если `mainPageData.fightState != null` -> вызвать `FightViewModel.processFight()`.
        - Если `mainPageData.isCureNeeded` -> вызвать `CureViewModel.startCure()`.
        - Если `mainPageData.isAutoMoving` -> вызвать `NavigatorViewModel.makeNextStep()`.
4.  **Реализовать под-модули (постепенно):**
    - [ ] **Инвентарь (`MainPhpInv.cs`):** Логику парсинга инвентаря вынести в `InventoryRepository`. UI инвентаря будет нативным `RecyclerView`, а не `WebView`.
    - [ ] **Быстрые действия (`MainPhpFast.cs`):** Логику поиска предмета и генерации запроса на его использование вынести в `ActionsRepository`. Вызываться будет из `ViewModel` по нажатию на кнопку в UI.
    - **Авто-лечение (`MainPhpAutoCure.cs`):** Логику вынести в `CureViewModel` и `CureRepository`.
5.  **Обновить `MainPhp.java`:**
    - Его единственной задачей будет:
        ```java
        public static byte[] process(String address, byte[] array) {
            String html = Russian.getString(array);
            // Получаем ссылку на MainViewModel (через Service Locator или DI)
            mainViewModel.processPage(html);
            // Возвращаем немодифицированный HTML, т.к. UI будет нативным
            return array;
        }
        ```

- [ ] Создать `data class MainPageData` для хранения всей информации со страницы `main.php`.
- [ ] Создать `MainPageRepository` с парсером на `Jsoup`.
- [ ] Создать `MainViewModel` для оркестрации логики.
- [ ] Последовательно портировать каждый `MainPhp*.cs` файл не как часть фильтра, а как часть соответствующего репозитория или `ViewModel`.
- [ ] Заменить все вызовы `BeginInvoke` на обновление `LiveData`.
- [ ] Заменить генерацию HTML-редиректов на вызовы методов в `ViewModel`'ях или навигационных команд.