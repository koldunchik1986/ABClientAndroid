# План портирования HelperStrings.cs

Файл `HelperStrings.cs` — это критически важный утилитарный класс, содержащий методы для сложного парсинга строк, в частности, HTML и JavaScript-кода.

## Функциональность в C#

*   **`SubString(html, s1, s2)`**: **Самый важный метод.** Он находит подстроку, заключенную между двумя другими строками (`s1` и `s2`). Это основной инструмент, используемый во всем проекте для извлечения данных из неструктурированного текста.
*   **`Replace(html, s1, s2, newStr)`**: Находит подстроку между `s1` и `s2` и заменяет ее.
*   **`ParseArguments(str)`, `ParsingUserinfo(posu)`, `ParseJsString(str)`**: Набор специфичных парсеров для разбора строк, которые выглядят как аргументы функций JavaScript или объявления массивов. Они работают на основе поиска кавычек и запятых, так как строки не всегда являются валидным JSON.
*   **`RandomArray(source)`**: Перемешивает строки в многострочном тексте в случайном порядке.

## План портирования на Android

**Портирование этого класса обязательно и должно быть выполнено с высокой точностью**, особенно для метода `SubString`, от которого зависит вся остальная логика извлечения данных.

1.  **Создать `StringUtils.java`** в пакете `ru.neverlands.abclient.utils`.

2.  **Реализовать `subString(String html, String s1, String s2)`**:
    ```java
    public static String subString(String html, String s1, String s2) {
        if (html == null || s1 == null || s2 == null) return null;
        
        // В C# IndexOf по умолчанию регистронезависимый для строк, в Java - нет.
        // Поэтому используем toLowerCase() для эмуляции.
        int p1 = html.toLowerCase().indexOf(s1.toLowerCase());
        if (p1 == -1) return null;
        
        p1 += s1.length();
        
        int p2 = html.toLowerCase().indexOf(s2.toLowerCase(), p1);
        if (p2 == -1) return null;
        
        return html.substring(p1, p2);
    }
    ```
    **Важно:** Оригинальный `IndexOf` использует `StringComparison.OrdinalIgnoreCase`. Эмуляция через `toLowerCase()` может работать некорректно с некоторыми Unicode-символами, но для HTML-тегов и латиницы это приемлемый и быстрый вариант. Более точным, но медленным был бы поиск с помощью `Pattern.compile(s1, Pattern.CASE_INSENSITIVE)`.

3.  **Реализовать остальные методы**:
    *   **`replace(...)`**: Реализуется аналогично `subString`, но с использованием `StringBuilder.replace()`.
    *   **`parse...` методы**: Аккуратно перенести логику посимвольного разбора с `indexOf` и `substring`. На этом этапе лучше не пытаться заменить их на регулярные выражения, чтобы не нарушить обработку каких-либо краевых случаев, на которые был рассчитан оригинальный код.
    *   **`randomArray(...)`**: Реализуется с помощью `source.split("\\r?\\n")`, фильтрации пустых строк и последующего вызова `java.util.Collections.shuffle()`.
