# Общий анализ папки ABProxy

Папка `ABProxy` содержит исходный код, реализующий полноценный локальный HTTP прокси-сервер. Это ядро всего C#-клиента, которое позволяет ему "вклиниваться" между браузерным компонентом и игровым сервером для перехвата и модификации трафика.

## Принцип работы в C#

1.  **Запуск прокси**: При старте приложения запускается `Proxy.cs`, который начинает слушать локальный порт (например, `127.0.0.1:8888`).
2.  **Перехват запроса**: Встроенный `WebBrowser` настроен на использование этого локального прокси. Когда игрок совершает действие (например, кликает на ссылку), `WebBrowser` отправляет HTTP-запрос не напрямую на `neverlands.ru`, а на `127.0.0.1:8888`.
3.  **Обработка**: `Proxy.cs` принимает запрос. Классы `ClientPipe` и `ServerPipe` управляют потоками данных. `HttpRequestHeaders` и `HttpResponseHeaders` парсят заголовки.
4.  **Запрос к серверу**: Прокси отправляет оригинальный запрос на реальный игровой сервер.
5.  **Перехват ответа**: Прокси получает ответ от сервера.
6.  **Фильтрация**: **(Ключевой момент)** Перед тем, как вернуть ответ браузеру, прокси передает его содержимое (URL и массив байт) в `PostFilter.Process(...)`. Именно здесь происходят все те модификации, которые мы анализировали ранее.
7.  **Возврат клиенту**: Модифицированный ответ возвращается компоненту `WebBrowser`, который его и отображает.

## Решение для портирования на Android

**Портировать всю эту реализацию прокси-сервера на сокетах НЕ НУЖНО.**

В Android SDK существует стандартный и гораздо более простой механизм для решения той же задачи — `WebViewClient.shouldInterceptRequest()`.

**Предлагаемая архитектура в Android:**

1.  Создать кастомный класс, наследующий от `WebViewClient`, например, `MyWebViewClient`.
2.  Переопределить в нем метод `shouldInterceptRequest(WebView view, WebResourceRequest request)`.
3.  **Внутри `shouldInterceptRequest` реализовать всю логику**:
    a. Получить URL запроса из `request.getUrl()`.
    b. Самостоятельно выполнить сетевой запрос к этому URL, используя современную HTTP-библиотеку, например, `OkHttp`.
    c. Получить от сервера ответ в виде массива байт (`byte[]`).
    d. Вызвать наш уже портированный фильтр: `byte[] modifiedBytes = Filter.process(url, originalBytes);`.
    e. Создать `WebResourceResponse` из модифицированных данных (указав `mime-type`, кодировку и поток `new ByteArrayInputStream(modifiedBytes)`).
    f. Вернуть этот `WebResourceResponse`. `WebView` получит его и отобразит так, как будто он пришел напрямую с сервера.

Этот подход намного проще, эффективнее и является стандартной практикой при работе с `WebView` в Android.

## Список файлов в папке

*   Cache.cs
*   ClientChatter.cs
*   ClientPipe.cs
*   CookiePack.cs
*   CookiePackItem.cs
*   CookiesManager.cs
*   DNSCacheEntry.cs
*   DNSResolver.cs
*   HttpHeaderItem.cs
*   HttpHeaders.cs
*   HttpRequestHeaders.cs
*   HttpResponseHeaders.cs
*   Parser.cs
*   Proxy.cs
*   ServerChatter.cs
*   ServerPipe.cs
*   Session.cs
*   Utilities.cs
