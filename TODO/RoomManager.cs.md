# План портирования RoomManager.cs

Этот документ описывает подробный план портирования `RoomManager.cs`. Этот компонент отвечает за отслеживание игроков в текущей локации, обнаружение "невидимок", авто-атаку врагов и предоставление UI для быстрой навигации.

## 1. Архитектурные проблемы и решения

*   **Агрессивный фоновый опрос**: Оригинальный код использует `Thread`, который опрашивает сервер каждые 100 мс. **Это абсолютно неприемлемо для мобильного приложения**, так как приведет к мгновенной разрядке батареи и огромному потреблению трафика.
    *   **Решение**: Полностью отказаться от этой модели. Вместо этого, обновление списка игроков должно происходить либо по действию пользователя (например, `SwipeRefreshLayout`), либо с помощью `WorkManager` с большим интервалом (не менее 30 секунд) и только когда приложение активно.
*   **Прямая работа с UI**: Код напрямую вызывает методы форм WinForms (`BeginInvoke`).
    *   **Решение**: Заменить на современный Android-подход. Логика должна находиться в `RoomManager` и `ViewModel` (`RoomViewModel`), а `Activity` или `Fragment` должны подписываться на изменения данных (`LiveData`) и обновлять UI.

## 2. Поэтапный план реализации

### Фаза 1: Создание "заглушки" (текущий этап)

Цель — обеспечить работоспособность приложения, реализовав только безопасные UI-модификации.

1.  **Создать `ChRoomPhp.java`**: Этот класс будет просто прокси, вызывающим `RoomManager.process()`.
2.  **Создать `RoomManager.java`**.
3.  **Реализовать `public static String process(String html)`**: В этом методе реализовать только ту часть логики из C#, которая модифицирует HTML, не требуя фоновых запросов или сложного состояния:
    *   Внедрение CSS-стилей для `a.activenick`.
    *   Внедрение выпадающего списка (`<select id="navbox">...`) для быстрой навигации.
    *   Изменение цвета фона, если включена опция `DoShowWalkers`.
    *   **Не реализовывать** логику определения невидимок, авто-атаки и отслеживания ушедших/пришедших.

### Фаза 2: Парсинг списка игроков

Цель — извлечь из HTML полный список игроков в локации.

1.  **Создать `PlayerInRoom.java`**: Data-класс для хранения информации об игроке в комнате (ник, уровень, клан и т.д.).
2.  **Реализовать `private static List<PlayerInRoom> parsePlayers(String html)`**: В `RoomManager.java` создать метод, который:
    *   Находит в HTML блок `var ChatListU = new Array(...)`.
    *   Парсит его, создавая список объектов `PlayerInRoom`.
3.  **Интегрировать с `ViewModel`**:
    *   Создать `RoomViewModel.java`.
    *   В нем создать `MutableLiveData<List<PlayerInRoom>> playersLiveData`.
    *   После парсинга, `RoomManager` должен обновлять `playersLiveData`.
    *   UI (Fragment/Activity) должен быть подписан на `playersLiveData` и отображать список в `RecyclerView`.

### Фаза 3: Обнаружение "ходоков" (Walkers)

Цель — определять, кто вошел в локацию и кто из нее вышел.

1.  **Управление состоянием**: `RoomManager` должен хранить предыдущий список игроков (`private static List<PlayerInRoom> previousPlayers = new ArrayList<>();`).
2.  **Реализовать `private static void detectWalkers(List<PlayerInRoom> newPlayers)`**:
    *   Сравнить `newPlayers` с `previousPlayers`.
    *   Игроки, которые есть в `newPlayers`, но не в `previousPlayers` — **пришедшие**.
    *   Игроки, которые есть в `previousPlayers`, но не в `newPlayers` — **ушедшие**.
    *   Сгенерировать сообщения для чата (например, "В локацию приходит: ...").
    *   Обновить `previousPlayers = newPlayers;`.

### Фаза 4: Логика невидимок и авто-атаки

1.  **Реализовать `private static void handleNevids(String html, List<PlayerInRoom> players)`**:
    *   Извлечь из HTML общее число персонажей в локации (`Всего: X`).
    *   Вычислить `nevidCount = totalCount - players.size()`.
    *   Если `nevidCount > 0`, внедрить в HTML блок с информацией о невидимках и кнопкой для их обнаружения.
2.  **Реализовать `private static void handleAutoAttack(List<PlayerInRoom> players)`**:
    *   Проверить, включена ли опция авто-атаки.
    *   Пройтись по списку `players` и для каждого игрока проверить его статус в `ContactsManager` (враг/друг).
    *   Если найден враг, инициировать действие атаки (например, через вызов метода в `MainPhpProcessor` или `AutoboiManager`).

### Фаза 5: Реализация фонового обновления

Цель — заменить недопустимый `Thread` на Android-совместимое решение.

1.  **Выбрать стратегию**: Определиться с механизмом обновления (ручной по свайпу, периодический через `WorkManager` и т.д.).
2.  **Реализация `WorkManager` (пример)**:
    *   Создать `RoomUpdateWorker.java`.
    *   В методе `doWork()` он должен будет выполнить сетевой запрос к `ch.php?lo=1`.
    *   Полученный HTML передать в `RoomManager.process()`.
    *   Запускать этого Worker-а периодически, только когда приложение находится на переднем плане.
