# Общий анализ папки Neuro

Папка `Neuro` содержит классы, реализующие алгоритм для распознавания капчи (гуамода).

## Функциональность в C#

При детальном анализе выяснилось, что это не нейронная сеть в классическом понимании, а реализация простого и эффективного алгоритма машинного обучения — **k-ближайших соседей (k-Nearest Neighbors, k-NN)**, где k=1.

*   **`NeuroVector.cs`**: Класс, описывающий "эталон" — пару из символа (цифры) и соответствующего ему вектора признаков (100 значений яркости пикселей от масштабированного изображения 10x10).
*   **`NeuroBase.cs`**:
    1.  **Загрузка базы**: При старте из файла `abneuro` загружается база эталонных векторов (`List<NeuroVector>`).
    2.  **Предобработка**: Метод `Calculate` принимает изображение капчи, проводит его бинаризацию (преобразование в ч/б), сегментацию (грубо режет на 5 частей по одной на цифру) и нормализацию (каждую цифру масштабирует до 10x10 пикселей и представляет в виде вектора из 100 чисел).
    3.  **Классификация**: Метод `FindVector` для каждого из 5 полученных векторов от капчи ищет в базе эталонов **ближайший** к нему вектор (с минимальным евклидовым расстоянием). Цифра, связанная с этим найденным ближайшим эталоном, и считается результатом распознавания.

## Решение для портирования на Android

**Портирование возможно и целесообразно.** В отличие от сложной нейросети, алгоритм k-NN достаточно прост, чтобы его можно было переписать на Java, не прибегая к тяжеловесным фреймворкам типа TensorFlow.

## План портирования

1.  **Создать `NeuroVector.java`**: Перенести класс `NeuroVector` на Java. Он должен содержать поле `char token` и `double[] matrix`. Также в нем должен быть метод `distance(double[] otherMatrix)`, вычисляющий евклидово расстояние.

2.  **Создать `CaptchaRecognizer.java`** (аналог `NeuroBase`):
    *   **`load(byte[] data)`**: Реализовать метод, который будет принимать байты файла `abneuro`, распаковывать их GZip (как это делает `UnpackArray` в оригинале) и с помощью `DataInputStream` читать данные, создавая `List<NeuroVector>`.
    *   **`recognize(Bitmap captchaBitmap)`**: Основной метод, аналог `Calculate`. Он должен будет:
        1.  Выполнить бинаризацию и сегментацию изображения с помощью стандартных методов `android.graphics.Bitmap`.
        2.  Для каждого сегмента (цифры) создать его масштабированную версию 10x10 пикселей. Это можно сделать с помощью `Bitmap.createScaledBitmap(...)`.
        3.  Преобразовать каждую масштабированную картинку 10x10 в вектор `double[100]`.
        4.  Для каждого вектора вызвать метод `findBestMatch(double[] vector)`.
    *   **`findBestMatch(double[] vector)`**: Приватный метод, аналог `FindVector`. Он будет итерировать по списку эталонов, вычислять расстояние до каждого и возвращать символ (`char`) того эталона, у которого расстояние минимально.

3.  **Интеграция**: Класс `Recognizer` из папки `MyGuamod` будет использовать этот новый `CaptchaRecognizer.java` для выполнения распознавания.