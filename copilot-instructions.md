# Copilot Instructions for ABClientAndroid

## Build, Test, and Lint Commands

- **Build APK (Debug):**
  - Windows: `gradlew.bat assembleDebug`
  - Linux/macOS: `./gradlew assembleDebug`
- **Build APK (Release):**
  - Windows: `gradlew.bat assembleRelease`
  - Linux/macOS: `./gradlew assembleRelease`
- **Clean build:**
  - `gradlew.bat clean` or `./gradlew clean`
- **Run all tests:**
  - `gradlew.bat test` or `./gradlew test`
- **Run a single test:**
  - `gradlew.bat test --tests <TestClassName>`
- **Lint:**
  - `gradlew.bat lint` or `./gradlew lint`

## High-Level Architecture

- **Monorepo:** Contains both the original Windows ABClient (C#) in `ABClient/` and the Android port in `app/`.
- **Porting Approach:**
  - All new development and bugfixes must be done in the Android code (`app/`).
  - The `ABClient/` folder is a read-only reference for porting logic and structure.
- **Key Android Modules:**
  - `ru.neverlands.abclient` — main application logic (see `MainActivity.java`, `LoginActivity.java`, `SettingsActivity.java`).
  - `ru.neverlands.abclient.proxy` — local proxy server for HTTP interception and modification.
  - `ru.neverlands.abclient.model` — data models (e.g., `UserConfig.java`).
  - Uses OkHttp for HTTP, WebView for rendering game UI, and AndroidX libraries for UI and navigation.
- **Automation:**
  - Built-in automation for in-game actions (fishing, gathering, mining, etc.)
  - Proxy and automation logic is ported from C# and must be preserved/adapted, not removed.
- **Debugging:**
  - Debug logs are written to the `Logs/` directory in the project root.
  - See `TODO/Debug/` for debug session logs and `TODO/todo_DebugApp.md` for complex debugging plans.

## Key Conventions

# Работа с кодовой базой: Новые правила

1.  **Папка `ABClient` является неизменяемой.**
    *   **Описание:** Директория `ABClient` содержит исходный код оригинальной ПК-версии. Эти файлы служат **эталоном** для портирования.
    *   **Правило:** **Категорически запрещено вносить изменения** в файлы внутри папки `ABClient`. Все исправления, новая логика и адаптация должны производиться исключительно в коде Android-приложения (в основном, в папке `app`).

2.  **Функционал должен портироваться, а не удаляться.**
    *   **Описание:** Ключевые возможности ПК-версии, такие как прокси, система автоматизации и другие, являются важной частью проекта.
    *   **Правило:** Моя задача — **исправлять или корректно портировать** этот функционал на Android, а не удалять его. Временное отключение функций (например, комментирование вызова) допустимо **только как диагностический шаг** для изоляции проблемы. Финальное решение должно содержать работающий аналог исходной функции.

# Анализ папки

Когда поступает задача проанализировать целую папку, необходимо создать сводный markdown-файл для отслеживания прогресса **анализа** каждого файла в этой папке. Для отслеживания общего прогресса **реализации** используется сводный файл верхнего уровня (например, `todo_ABClient.md`).

### Статус-маркеры

*   `[ ]` - **Не проанализирован**: Детальный анализ файла еще не проводился.
*   `[x]` - **Проанализирован**: Детальный анализ файла (`todo_filename.md`) завершен.
*   `[-]` - **Отложен**: Анализ или реализация отложены.
*   `[+]` - **Реализован/Портирован**: Весь функционал, описанный в файле или папке, полностью реализован в Android-версии.

### Шаг 1: Создание сводного файла анализа папки (`todo_FolderName.md`)

1.  **Расположение:** `TODO\todo_FolderName.md`.
2.  **Назначение:** Отслеживать **статус анализа** каждого файла внутри папки `FolderName`.
3.  **Структура:**

    ```markdown
    # Анализ папки [FolderName]

    ## Список файлов и статус анализа

    | Файл             | Описание                               | Статус подробного анализа |
    | ---------------- | -------------------------------------- | -------------------------
    | `[FileName1.cs]` | [Краткое описание]                     | `[ ]` Не проанализирован      
    | `[FileName2.cs]` | [Краткое описание]                     | `[x]` Проанализирован         
    ```

#### ВАЖНО: Алгоритм размещения TODO-анализа
- Если исходный файл (например, RoomManager.cs) находится в **корне** папки ABClient, то соответствующий TODO-файл размещается в корне `TODO/todo_ABClient/` с именем `todo_RoomManager.cs.md`.
- Если исходный файл находится в подпапке (например, ABClient/Lez/LezFight.cs), то TODO-файл размещается в `TODO/todo_ABClient/Lez/todo_LezFight.cs.md`.
- Не создавать лишних подпапок для файлов из корня ABClient.

### Шаг 2: Обновление сводного файла проекта (`todo_ProjectName.md`)

1.  **Расположение:** `TODO\todo_ProjectName.md` (например, `TODO\todo_ABClient.md`).
2.  **Назначение:** Отслеживать общий **статус реализации (портирования)** для каждой папки.
3.  **Процесс:**
    *   Когда **все** задачи по портированию функционала из папки `FolderName` выполнены (то есть, все ее файлы не просто проанализированы, а их функционал реализован в Android), статус этой папки в файле `todo_ProjectName.md` меняется на `[+]`.

    ```markdown
    # Анализ папки ABClient

    ## Список подпапок и статус реализации

    | Папка     | Описание                               | Статус реализации |
    | --------- | -------------------------------------- | -----------------
    | `Forms`   | Основные формы и диалоги.              | `[+]` Реализована     
    | `Helpers` | Вспомогательные классы.                | `[ ]` Не реализована  
    ```


### Шаг 3: Процесс работы

### Шаг 3: Процесс работы

1.  **Первичное сканирование и проверка:**
    *   Получите список **всех файлов** (включая `.cs`, `.xml`, `.js`, `.resx` и т.д.) в анализируемой папке (например, `ABClient\PostFilter`).
    *   Получите список всех `.md` файлов в соответствующей папке с анализами (например, `TODO\todo_ABClient\todo_PostFilter`).
    *   В сводном файле `todo_PostFilter.md` создайте таблицу и изначально пометьте все файлы статусом `[ ] Не проанализирован`, если для них еще не создан детальный `.md` файл.
    *   **Проверьте соответствие существующих `.md` файлов:** Одновременно просмотрите соответствующую папку с анализами (`TODO\todo_ABClient\todo_PostFilter`). Если в ней есть файлы `todo_*.md`, убедитесь, что они действительно описывают файлы из папки `ABClient\PostFilter`. Если найден несоответствующий файл, сообщите об этом.
    *   **Сравните количество и состав файлов:** Убедитесь, что для каждого файла в исходной папке существует соответствующий `todo_filename.filetype.md` файл в папке анализа.
    *   **При расхождении:** Если обнаружено, что для какого-либо файла отсутствует `.md` файл, необходимо немедленно создать его, проведя подробный анализ этого файла и занеся результаты в новый `.md` файл согласно общим инструкциям.
    *   **Проверьте соответствие существующих `.md` файлов:** Если в папке анализа есть файлы `todo_*.md`, убедитесь, что они действительно описывают существующие файлы в исходной папке. Если найден несоответствующий `.md` файл (описывающий удаленный или переименованный исходный файл), сообщите об этом.
    *   Для каждого файла в исходной папке постарайтесь дать краткое описание его назначения в сводном файле `todo_FolderName.md`.
    *   В сводном файле `todo_FolderName.md` создайте или обновите таблицу, помечая все файлы, для которых еще не создан детальный `.md` файл, статусом `[ ] Не проанализирован`.

2.  **Детальный анализ файла:**
    *   Когда вы приступаете к детальному анализу конкретного файла (например, `FileName1.cs` из папки `FolderName`), вы создаете для него отдельный файл в **новой подпапке** внутри `TODO`.
    *   **Расположение:** `TODO\FolderName\todo_FileName1.cs.md`

3.  **Обновление сводного файла:**
    *   После завершения (или переноса) детального анализа файла, **обязательно обновите статус** этого файла в сводном файле `TODO\todo_FolderName.md`.
    *   Измените `[ ]` на `[x]` (проанализирован) или `[-]` (отложен).
    *   Это позволяет иметь высокоуровневое представление о прогрессе анализа всей папки.

**Пример использования:**

1.  **Задача:** "Проанализируй папку `ABClient\Forms`".
2.  **Действие:**
    *   Проверяем, есть ли `TODO\todo_Forms.md`. Нет.
    *   Создаем `TODO\todo_Forms.md`.
    *   Сканируем папку `ABClient\Forms`, находим `FormProfile.cs`, `FormProfiles.cs` и т.д.
    *   Заполняем таблицу в `TODO\todo_Forms.md`.

3.  **Задача:** "Проанализируй `FormProfile.cs` из папки `Forms`".
4.  **Действие:**
    *   Создаем подпапку `TODO\Forms` (если ее нет).
    *   Создаем `TODO\Forms\todo_FormProfile.cs.md` и проводим детальный анализ.
    *   После завершения, открываем `TODO\todo_Forms.md` и обновляем статус для `FormProfile.cs` на `[x] Проанализирован`.


# Инструкция по созданию подробного анализа для портирования

## Основные правила

1.  **Подробный анализ:** При выполнении портирования кода с ПК версии (C#) на Android (Java/Kotlin) необходимо сначала провести подробный анализ исходного файла. Результаты анализа должны быть записаны в файл `TODO\FolderName\todo_filename.cs.md` на русском языке.
2.  **Соблюдение названий:** Обязательно соблюдать названия переменных, функций и констант из ПК версии в Android версии для сохранения преемственности и облегчения отладки.
3.  **Ведение списка задач:** Всегда вести подробный список задач в файле `todo_task_timestamp.md` на русском языке и обновлять его по мере выполнения.

## Процесс портирования

### Шаг 1: Анализ и документирование

1.  **Анализ исходного C# файла:**
    *   **Задача:** Полностью понять, что делает класс, его методы, с какими данными и UI он работает в оригинальном приложении.
    *   Это первый и самый важный шаг в `todo_filename.cs.md`.

2.  **Проверка на существующую реализацию в Android:**
    *   **Когда:** *После* того, как вы полностью поняли функциональность C# кода.
    *   **Как:** Искать в Android-проекте по ключевым словам, названиям классов, уникальным строкам.
    *   **Результат:** Этот шаг определяет дальнейший план. Либо мы портируем с нуля, либо дорабатываем существующий код.

3.  **Написание плана портирования:**
    *   На основе результатов предыдущих двух шагов составляется детальный план действий для Android-версии.
    *   **Промпт для анализа:** Перед созданием кода портированного приложения, необходимо проанализировать текущий код Android приложения на наличие уже присутствующих элементов. Если их нет, то уже реализовывать подробно.

**Фраза-триггер:** "*Обязательно производить сначала запись анализа и подробных описаний и инструкций в TODO\todo_filename.filetype.md на руссокм языке, а после уже приступать к написанию кода...*"

**Расшифровка:**

После того как вы убедились, что функциональность не реализована, приступайте к анализу и документированию:

1.  **Полностью проанализировать исходный файл** из ПК-версии (например, `MyClass.cs`).
2.  **Создать markdown-файл** в папке `TODO` с именем, соответствующим исходному файлу (например, `TODO\todo_MyClass.cs.md`).
3.  **Заполнить этот файл подробной информацией** на русском языке, включая:
    *   **Назначение файла:** Что делает этот класс/компонент в оригинальном приложении.
    *   **Анализ UI (если применимо):** Описание всех элементов интерфейса, их состояний и событий.
    *   **Анализ логики:** Описание ключевых методов, алгоритмов, используемых переменных и констант.
    *   **Взаимодействие:** Как этот компонент связан с другими частями приложения.
    *   **План портирования:** Конкретные шаги по переносу функциональности на Android, включая выбор подходящих Android-компонентов и архитектурных решений.

### Шаг 2: Написание кода и отслеживание прогресса

**Фраза-триггер:** *"...а после уже приступать к написанию кода с подробным описанием и подробнными сносками используя названия функций, переменных и констант и приблизительной архитектуры и названия папок, в как в ПК версии (из которой мы портируем)"*

**Расшифровка:**

После того как файл анализа создан и утвержден, можно приступать к написанию кода, соблюдая следующие принципы:

1.  **Преемственность названий:**
    *   **Переменные:** `userName` в C# должен стать `userName` в Java/Kotlin.
    *   **Функции/Методы:** `CalculateTotal()` в C# должен стать `calculateTotal()` в Java/Kotlin (с поправкой на конвенцию именования).
    *   **Константы:** `MAX_USERS` в C# должен стать `MAX_USERS` в Java/Kotlin.
2.  **Архитектурное соответствие:**
    *   **Структура папок:** Если в ПК-версии есть папка `Helpers` или `Utils`, следует создать аналогичную структуру в Android-проекте (например, `helpers` или `utils` в соответствующем пакете).
    *   **Архитектурные паттерны:** Если в оригинальном коде используется определенный паттерн (например, Singleton, Factory), следует по возможности воспроизвести его в портированной версии, адаптируя под особенности Android.
3.  **Подробное описание кода:**
    *   При написании кода оставлять комментарии, объясняющие сложные или неочевидные моменты, особенно если реализация на Android сильно отличается от оригинала.
    *   В описании коммитов или в отчетах о проделанной работе давать подробные сноски и объяснения, почему были приняты те или иные решения.

**Отслеживание статуса задач:**

В процессе выполнения задач, описанных в `todo_*.md` файлах, необходимо маркировать их статус. Используйте следующие обозначения:

*   `[x]` - **Выполнено**
*   `[ ]` - **Не выполнено**
*   `[-]` - **Отложено** (если выполнение задачи по какой-то причине блокируется или переносится)

**Пример:**

```markdown
### План реализации

- [x] Создать layout-файл `activity_profile.xml`
- [x] Создать класс `ProfileActivity.java`
- [ ] Реализовать логику сохранения данных
- [-] Реализовать функцию `DetectProxy()` (отложено до реализации сетевого модуля)
```

## Структура файла анализа (`todo_filename.cs.md`)

Файл анализа должен содержать следующие разделы:

### 1. План портирования [ИмяФайла].cs

Краткое описание назначения исходного файла. Например: `Файл AutoLogon.cs реализует диалоговое окно с обратным отсчетом перед автоматическим входом в игру.`

### 2. Функциональность в C#

Подробное описание того, как реализована функциональность в исходном C# коде.

*   **Назначение:** Какую задачу выполняет данный компонент?
*   **UI:** Какие элементы пользовательского интерфейса используются и как они выглядят?
*   **Логика:** Как работает основная логика? Какие классы, методы и события используются? Как обрабатываются пользовательские взаимодействия?
*   **Данные:** Как и где хранятся данные, связанные с этим компонентом?

**Пример для `AutoLogon.cs`:**

*   **Назначение**: Дать пользователю несколько секунд, чтобы отменить автоматический вход в игру. Если пользователь ничего не делает, вход происходит автоматически.
*   **UI**: Окно отображает имя пользователя, для которого выполняется вход, и две кнопки: "Отмена" и кнопка подтверждения (например, "Войти (10)").
*   **Обратный отсчет**: При открытии окна запускается `System.Windows.Forms.Timer`. Каждую секунду он уменьшает счетчик и обновляет текст на кнопке подтверждения, показывая оставшееся время.
*   **Авто-подтверждение**: Когда счетчик доходит до нуля, форма автоматически закрывается с результатом `DialogResult.OK`, что инициирует вход в игру.
*   **Отмена**: Пользователь может нажать кнопку "Отмена", чтобы прервать таймер и отменить автологин.

### 3. Решение для портирования на Android

Описание того, как данная функциональность будет реализована на Android. Какие классы и подходы будут использоваться?

**Пример для `AutoLogon.cs`:**

Эта функциональность легко реализуется с помощью стандартного `AlertDialog` и системного класса `android.os.CountDownTimer`.

### 4. План реализации

Пошаговый план реализации на Android.

1.  **Создание UI:** Описание того, как будет создан пользовательский интерфейс (XML-разметка или программно).
2.  **Реализация логики:** Подробное описание того, как будет реализована логика, включая создание методов, обработчиков событий и т.д.
3.  **Взаимодействие с другими компонентами:** Как новый компонент будет взаимодействовать с другими частями приложения.

**Пример для `AutoLogon.cs`:**

1.  **Создать утилитный метод** для показа диалога, который будет принимать `Context`, имя пользователя и `callback` для обработки результата.
    ```java
    public interface AutoLogonCallback {
        void onLoginConfirmed();
        void onLoginCancelled();
    }

    public static void showAutoLogonDialog(Context context, String userName, AutoLogonCallback callback) { ... }
    ```

2.  **Реализация `showAutoLogonDialog`**:
    *   Создать `AlertDialog.Builder` с заголовком "Автоматический вход" и сообщением, включающим `userName`.
    *   Установить кнопки:
        ```java
        builder.setNegativeButton("Отмена", (dialog, which) -> {
            // Таймер будет остановлен в обработчике onCancel
        });
        builder.setPositiveButton("Войти", (dialog, which) -> {
            // Этот обработчик сработает при нажатии или по окончании таймера
            callback.onLoginConfirmed();
        });
        ```
    *   Создать и показать диалог: `AlertDialog dialog = builder.create(); dialog.show();`

3.  **Настройка `CountDownTimer`**:
    *   После `dialog.show()`, получить ссылку на кнопку подтверждения: `final Button positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE);`
    *   Создать и запустить `CountDownTimer`:
        ```java
        final CountDownTimer timer = new CountDownTimer(10000, 1000) { // 10 секунд
            @Override
            public void onTick(long millisUntilFinished) {
                positiveButton.setText("Войти (" + (millisUntilFinished / 1000) + ")");
            }

            @Override
            public void onFinish() {
                if (dialog.isShowing()) {
                    dialog.dismiss();
                    callback.onLoginConfirmed();
                }
            }
        }.start();
        ```

4.  **Обработка отмены**:
    *   Добавить слушатель отмены/закрытия диалога, в котором будет останавливаться таймер, чтобы избежать утечек и лишних срабатываний.
        ```java
        dialog.setOnCancelListener(dialogInterface -> {
            timer.cancel();
            callback.onLoginCancelled();
        });
        ```
        Обработчик `setNegativeButton` также вызовет `OnCancelListener`.

# Комплексная отладка (Debug)

При возникновении сложных, многоуровневых или взаимосвязанных проблем, которые затрагивают несколько модулей или требуют глубокого анализа, необходимо придерживаться следующего процесса:

1.  **Создание основного файла отладки:** Первым шагом является создание файла `TODO/todo_DebugApp.md` (или с другим соответствующим названием).
2.  **Назначение файла:** Этот файл становится центральным местом для:
    *   Полного и подробного описания всех наблюдаемых проблем.
    *   Декомпозиции комплексной проблемы на отдельные, более мелкие подзадачи.
    *   Формулирования гипотез о причинах каждой подзадачи.
    *   Составления пошагового плана для диагностики и решения каждой подзадачи.
    *   Отслеживания прогресса с помощью стандартных статус-маркеров (`[ ]`, `[x]`, `[-]`).
3.  **Системный подход:** Решение проблем должно происходить поэтапно, в соответствии с планом, изложенным в `todo_DebugApp.md`.

# Работа с файлами анализа (TODO)

Перед началом любой разработки, исправления или отладки, связанной с портированием функционала из ПК-версии, **обязательно** необходимо обращаться к соответствующим файлам анализа в папке `TODO`.

1.  **Поиск документации:** Если задача касается файла `SomeClass.java`, необходимо найти и изучить файл `todo_SomeClass.cs.md` в соответствующей подпапке `TODO`.
2.  **Следование плану:** Эти `*.md` файлы содержат подробный анализ оригинального C# кода, а также утвержденный план портирования на Android. Необходимо следовать этому плану, чтобы обеспечить соответствие архитектуры и логики.
3.  **Источник истины:** Файлы анализа являются "источником истины" по запланированной реализации. Отклонения от плана возможны, но должны быть обоснованы.

# Отладка и Логирование

Для отладки сложных проблем, связанных с сетевым взаимодействием и обработкой данных, в проекте реализована система детального логирования.

-   **Расположение логов:** Детальные debug-логи, создаваемые классом `DebugLogger`, сохраняются в папку `Logs` **в корне проекта**.
-   **Именование файлов:** `Log_{timestamp}.txt` (например, `Log_20250927_111808.txt`).
-   **Получение логов:** Эти файлы создаются приложением в его внутренней директории. Для анализа их необходимо вручную извлечь с устройства и поместить в папку `Logs` в корне проекта.

# Журналирование действий при отладке

В дополнение к основному файлу отладки (`TODO/todo_DebugApp.md`), для каждой сессии отладки может создаваться отдельный файл журнала в папке `TODO/Debug/`.

1.  **Именование файла:** `debug_log_{timestamp}.md` (например, `debug_log_20250929_123000.md`).
2.  **Назначение:** Этот файл служит для ведения хронологического, неизменяемого журнала **всех действий**, предпринятых в ходе отладки. В отличие от `todo_DebugApp.md`, который содержит высокоуровневый план и статус, этот файл фиксирует сам пошаговый процесс поиска и решения проблемы.
3.  **Содержимое:** В файл последовательно записываются:
    *   **Действие:** Какая команда была выполнена (`read_file`, `run_shell_command`, `replace` и т.д.).
    *   **Обоснование:** Краткое объяснение, почему это действие было необходимо в данный момент.
    *   **Результат:** Краткий итог выполнения (например, "Файл прочитан", "Сборка успешна", "Обнаружена ошибка X в логах").
    *   **Выводы:** Какие умозаключения сделаны на основе полученного результата и какой следующий шаг.

Это позволяет не "заменять проделанные работы" в основном файле, а иметь полную историю анализа и исправлений для последующего разбора. Основной файл `todo_DebugApp.md` при этом продолжает использоваться для общего плана и отслеживания статуса верхнеуровневых задач.

## Integration with AI Assistants

- **Claude:** See `CLAUDE.md` for any Claude-specific rules (if present).
- **Copilot:** Follow this file and the `TODO/` analysis files for all porting and implementation work.

---

This file summarizes build/test commands, architecture, and key conventions for Copilot and other AI assistants. Would you like to adjust anything or add coverage for additional areas (e.g., CI/CD, release process, or more details on automation/proxy logic)?
