# Инструкция по работе прокси и кэширования

Этот документ описывает архитектуру и принцип работы локального прокси-сервера и механизма кэширования в Android-приложении ABClient.

## 1. Общая архитектура

Вместо стандартного для Android перехвата запросов через `WebViewClient.shouldInterceptRequest()`, приложение использует более низкоуровневый и полный подход:

1.  **Локальный HTTP-прокси:** На самом устройстве запускается полноценный HTTP-прокси-сервер в виде фонового сервиса (`ProxyService`).
2.  **Глобальная настройка прокси:** `WebView` (и все приложение) настраивается на использование этого локального прокси через установку системных свойств JVM.
3.  **Полный контроль:** Такой подход дает полный контроль над всем HTTP-трафиком от `WebView`, позволяя реализовать сложную логику кэширования, модификации и фильтрации запросов и ответов.

## 2. Ключевые компоненты

| Класс / Файл                      | Расположение                                    | Назначение                                                                                                                              |
| --------------------------------- | ----------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `MainActivity.java`               | `ru.neverlands.abclient`                        | Главная активность. Отвечает за запуск `ProxyService` и установку системных настроек прокси.                                          |
| `ProxyService.java`               | `ru.neverlands.abclient.proxy`                  | Android `Service`, который живет в фоне. Создает `ServerSocket`, слушает порт и для каждого входящего соединения запускает `SessionHandler`. |
| `SessionHandler.java`             | `ru.neverlands.abclient.proxy`                  | "Рабочая лошадка". Обрабатывает одно клиентское соединение от `WebView`. Здесь происходит вся магия: кэширование, запросы, модификация. |
| `Cache.java`                      | `ru.neverlands.abclient.proxy`                  | Реализует двухуровневый кэш: быстрый в памяти (in-memory `HashMap`) и постоянный на диске (в папке `abcache` во внешнем хранилище).     |
| `AppVars.java`                    | `ru.neverlands.abclient.utils`                  | Хранит глобальные переменные, включая адрес (`LocalProxyAddress`) и порт (`LocalProxyPort`) для локального прокси.                      |

## 3. Жизненный цикл и поток данных

### Шаг 1: Запуск и настройка

1.  **`MainActivity.onCreate()`**: Сразу при старте, еще до создания `WebView`, вызывается:
    ```java
    System.setProperty("http.proxyHost", AppVars.LocalProxyAddress); // "127.0.0.1"
    System.setProperty("http.proxyPort", String.valueOf(AppVars.LocalProxyPort)); // e.g., 8052
    ```
    Это заставляет `WebView` направлять все свои запросы на `localhost:8052`.

2.  **`MainActivity.onCreate()`**: Далее запускается сам прокси-сервис:
    ```java
    ((ABClientApplication) getApplication()).startProxyService();
    ```

3.  **`ProxyService.onStartCommand()`**: Сервис запускается в режиме `foreground` (с постоянным уведомлением), что защищает его от убийства системой. Он вызывает `startProxyServer()`.

4.  **`ProxyService.startProxyServer()`**: В отдельном потоке создается `ServerSocket`, который начинает слушать порт, указанный в `AppVars`. Если порт занят, он пытается взять следующий. После успешного старта он входит в бесконечный цикл `while (!serverSocket.isClosed())`, ожидая подключения.

### Шаг 2: Обработка запроса

1.  **`WebView` делает запрос**: Например, на `http://neverlands.ru/main.php`. Благодаря системным настройкам, этот запрос отправляется на `127.0.0.1:8052`.

2.  **`ProxyService` принимает запрос**: `serverSocket.accept()` возвращает `Socket` клиента. Этот сокет немедленно передается в новый экземпляр `SessionHandler`, который запускается в отдельном потоке из пула `executorService`.

3.  **`SessionHandler.run()`**: Начинается обработка:
    *   **Чтение запроса**: Из `clientSocket` читаются HTTP-заголовки.
    *   **Проверка на "особые" URL**: Ссылки на счетчики (`top.list.ru`, `counter.yadro.ru`) блокируются, и клиенту сразу отдается ответ `304 Not Modified`.
    *   **Проверка кэша (`isCacheable` и `Cache.get`)**: Если URL — это изображение, CSS, JS или одна из ключевых страниц (`main.php`, `ch.php`), `SessionHandler` обращается к `Cache.java`.
        *   **Найдено в кэше**: `Cache.get()` возвращает массив байт. `SessionHandler` немедленно формирует HTTP-ответ `200 OK` с этими данными и отправляет его в `WebView`. **Запрос в интернет не уходит.**
        *   **Не найдено в кэше**: `Cache.get()` возвращает `null`. Обработка продолжается.

### Шаг 3: Запрос в интернет и обработка ответа

1.  **`SessionHandler.sendRequestToServer()`**: Создается `HttpURLConnection` к реальному серверу (`neverlands.ru`). При этом:
    *   Копируются все заголовки из исходного запроса `WebView`.
    *   Внедряются актуальные `Cookie` из `CookiesManager`.
    *   При необходимости используется "внешний" прокси из настроек профиля.

2.  **Получение ответа**: `SessionHandler` получает код ответа, заголовки и тело ответа от сервера.

3.  **Анализ ответа**:
    *   **Если это HTML (`text/html`)**:
        1.  Тело ответа **полностью вычитывается в память**.
        2.  Если контент сжат (`Content-Encoding: gzip`), он **распаковывается**.
        3.  В HTML-код **внедряется JS-фикс** (`injectJsFix`), который добавляет заглушки для недостающих функций (`top.start`, `chatlist_build` и т.д.), чтобы избежать ошибок JavaScript в `WebView`.
        4.  Модифицированное тело ответа отправляется в `WebView` с правильным `Content-Length`.
        5.  Если ответ `200 OK`, модифицированное тело сохраняется в кэш (`Cache.store`).
    *   **Если это не HTML (картинка, CSS и т.д.)**:
        1.  `SessionHandler` **не читает тело в память**, а работает в режиме стриминга для экономии ресурсов.
        2.  Он отправляет `WebView` заголовки, полученные от сервера.
        3.  Затем он одновременно читает поток байт от сервера и тут же перенаправляет его в `WebView`. Параллельно эти же байты пишутся во временный буфер.
        4.  После завершения стриминга, данные из буфера сохраняются в кэш (`Cache.store`).

## 4. Механизм кэширования (`Cache.java`)

*   **Ключ**: URL преобразуется в ключ (убирается `http://` и параметры после `?`).
*   **Кэш в памяти (`memCache`)**: `HashMap<String, byte[]>` для максимально быстрых ответов.
*   **Кэш на диске**: Если в `memCache` данных нет, происходит чтение с диска из папки `(внешнее хранилище)/abcache/`. Имя файла соответствует ключу, а структура папок повторяет путь URL.
*   **Запись**: При сохранении данные попадают и в `memCache`, и на диск (если `storeToDisk` = `true`).
*   **Очистка**: `Cache.clear()` очищает только кэш в памяти. Для полной очистки нужно удалять папку `abcache`.
