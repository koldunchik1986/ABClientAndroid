# Анализ и архитектура проксирования в `MainActivity`

**Файл:** `app/src/main/java/ru/neverlands/abclient/MainActivity.java` (внутренний класс `CustomWebViewClient`)

## 1. Общая схема

В приложении отсутствует традиционный фоновый прокси-сервис. Вместо этого, вся логика перехвата, кэширования, и модификации сетевых запросов реализована внутри метода `shouldInterceptRequest` кастомного `WebViewClient`.

Эта архитектура работает как "прокси на лету" (on-the-fly proxy) для всех запросов, исходящих от `WebView`.

**Основная цель:**
-   Снизить трафик и ускорить загрузку за счет кэширования статических ресурсов в `assets`.
-   Модифицировать ответы от сервера для исправления ошибок, внедрения дополнительного функционала и извлечения данных.
-   Обеспечить корректную аутентификацию для всех запросов `WebView`.

## 2. Пошаговый алгоритм `shouldInterceptRequest`

Каждый раз, когда `WebView` пытается загрузить какой-либо ресурс (HTML, JS, CSS, изображения), вызывается этот метод.

### Шаг 1: Попытка загрузки из Assets (Кэш)
-   **Механизм:** Первым делом код пытается загрузить запрошенный файл напрямую из папки `assets` приложения.
-   **Логика:**
    1.  URL запроса преобразуется в имя файла.
    2.  Вызывается `readAssetFile(fileName)`.
    3.  Если файл найден в `assets`, его содержимое читается, и немедленно создается `WebResourceResponse`. **Сетевой запрос в этом случае не выполняется.**
-   **Особый случай:** Для файла `ch/ch_list.js` перед возвратом в него динамически внедряется JS-код (`window.external = window.AndroidBridge;`) и массив `AppVars.chatListU`.

### Шаг 2: Сетевой запрос (Если в Assets нет)
-   Если файл не найден в `assets`, метод переходит к выполнению полноценного сетевого запроса.
-   **Механизм:** Создается новый `java.net.HttpURLConnection`.
-   **Заголовки и Cookies:**
    1.  Копируются все заголовки из оригинального `WebResourceRequest` в новый `HttpURLConnection`.
    2.  **Ключевой шаг аутентификации:** Вызывается `CookiesManager.obtain(url)` для получения актуальной строки cookies из системного `CookieManager` (который был наполнен после логина).
    3.  Полученная строка устанавливается в заголовок `Cookie` для `HttpURLConnection`.

### Шаг 3: Обработка ответа от сервера
-   **Чтение:** Метод читает тело ответа из `InputStream` соединения.
-   **Декомпрессия:** Проверяется заголовок `Content-Encoding`. Если он равен `gzip`, тело ответа распаковывается с помощью `GZIPInputStream`.
-   **Парсинг и извлечение данных:**
    -   Если URL запроса содержит `ch.php?lo=1`, HTML-ответ парсится с помощью регулярного выражения (`Pattern.compile`) для извлечения содержимого JS-массива `ChatListU`. Найденная строка сохраняется в глобальную переменную `AppVars.chatListU` для последующего использования (см. Шаг 1, особый случай).
-   **Модификация ответа (Фильтрация):**
    -   Вызывается статический метод `ru.neverlands.abclient.postfilter.Filter.process(url, data)`.
    -   Этот метод действует как диспетчер: в зависимости от URL, он вызывает соответствующий статический метод из других классов в пакете `postfilter` (например, `MainPhp.java`, `GamePhp.java`, `ChListJs.java`).
    -   Каждый из этих классов-фильтров выполняет свои специфичные модификации над телом ответа (например, заменяет текст, добавляет HTML-элементы, исправляет верстку).
-   **Внедрение JS-фикса:** Для всех HTML-страниц (`contentType.contains("text/html")`) в начало документа внедряется большой блок JavaScript-кода (`injectJsFix`). Этот код создает пустые заглушки для функций (`top.start`, `window.chatlist_build` и т.д.), чтобы избежать ошибок `undefined function` в `WebView`.

### Шаг 4: Возврат `WebResourceResponse`
-   **Механизм:** После всех модификаций создается и возвращается новый `WebResourceResponse`.
-   **Параметры:**
    -   `mimeType`: MIME-тип, полученный из заголовка `Content-Type` ответа.
    -   **`encoding`:** **`windows-1251`**. Эта кодировка жестко задана для всех ответов, что является ключевым моментом для корректного отображения кириллицы в `WebView`.
    -   `data`: Модифицированное тело ответа в виде `ByteArrayInputStream`.

## 3. Ключевые классы и зависимости

-   `MainActivity$CustomWebViewClient`: Основной класс, реализующий логику.
-   `CookiesManager`: Хелпер для доступа к системному `CookieManager`.
-   `ru.neverlands.abclient.postfilter.Filter`: Диспетчер, управляющий цепочкой фильтров.
-   Классы в `ru.neverlands.abclient.postfilter.*`: Содержат конкретные правила модификации для разных страниц.
-   `AppVars`: Глобальный класс для хранения состояния между компонентами (например, `AppVars.chatListU`).
