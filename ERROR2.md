Корень проблемы: Две независимые и конфликтующие системы обработки ch.php?lo=1
В вашем Android-приложении существует два разных механизма, которые пытаются обработать фрейм комнаты (ch.php?lo=1), и они работают независимо друг от друга, что приводит к конфликту и непредсказуемому поведению.

Система 1: Фоновый опрос через RoomManager.startTracing
Где запускается: В MainActivity.java, в WebViewClient.shouldInterceptRequest при загрузке main.php.
Что делает: Запускает фоновый поток, который каждые 100 мс делает прямой HTTP-запрос к http://www.neverlands.ru/ch.php?lo=1 через HttpURLConnection.
Проблема: Этот запрос не использует куки из WebView. Он делается "вслепую", без сессии пользователя.
Результат: Сервер возвращает ошибку 404 или пустую страницу, что видно в logcat.txt:
java.io.FileNotFoundException: http://www.neverlands.ru/ch.php?lo=1

Из-за этого RoomManager.process() никогда не получает правильный HTML с ChatListU и, следовательно, никогда не генерирует JS-код для отображения списка.
Система 2: Обработка через Filter.java и ChListJs.java
Где запускается: В MainActivity.java, в WebViewClient.shouldInterceptRequest для любого запроса, включая ch.php?lo=1.
Что делает: Когда WebView сам загружает ch.php?lo=1 (как часть фреймсета), запрос перехватывается Filter.java. Filter.java передаёт HTML в ChListJs.java.
Что делает ChListJs.java: Он парсит ChatListU из полученного HTML и вставляет его обратно в начало ch_list.js.
Проблема: ChListJs.java только парсит и вставляет ChatListU. Он НЕ вызывает функцию chatlist_build(), которая фактически отображает список на странице. Он полагается на то, что оригинальный HTML ch.php?lo=1 уже содержит вызов chatlist_build().
Результат: В логах HtmlLog_ChatUsers_*.txt мы видим, что ChatListU присутствует в HTML, и даже есть вызов chatlist_build('33_0'). Почему же тогда список не отображается?
Финальный диагноз: Проблема с JavaScript-окружением
Даже если ChatListU и chatlist_build присутствуют в HTML, ch_list.js не может выполниться корректно, потому что он написан для работы в полноценном фреймсете браузера, где есть объект top и другие фреймы (ch_refr, chmain и т.д.).

Ваше Android-приложение загружает ch.php?lo=1 в изолированный WebView, который не является частью оригинального фреймсета. Поэтому:

top — это сам WebView, а не родительский фреймсет.
Объекты вроде top.OnlineStop, top.reload, top.frames['ch_refr'] не существуют или имеют неправильное значение.
При выполнении ch_list.js возникают JavaScript-ошибки, которые останавливают выполнение скрипта до того, как он доходит до chatlist_build.
Это объясняет, почему при первом запуске (когда кеш пуст и все ресурсы загружаются свежие) иногда может сработать "магия" (например, если WebView успевает инициализировать окружение), а при повторном запуске (когда страница может загружаться из кеша в неполном состоянии) — нет.

Решение: Унифицировать подход и взять контроль на себя
Вам нужно отказаться от фонового опроса RoomManager.startTracing для получения HTML и полностью взять на себя генерацию списка в рамках Filter.java.

Шаг 1: Удалить фоновый опрос из RoomManager.java
Удалите методы startTracing, stopTracing и все связанные с ними поля (scheduler, doStop и т.д.).
Этот механизм избыточен и работает неправильно.
Шаг 2: Модифицировать ChListJs.java для полной генерации списка
ChListJs.java должен не просто вставлять ChatListU в ch_list.js, а создавать полностью самодостаточный HTML-фрагмент.

Вот как это должно работать:

Парсинг: ChListJs.process получает HTML от ch.php?lo=1.
Извлечение данных: Он парсит ChatListU и извлекает данные о игроках.
Генерация HTML: Вместо того чтобы полагаться на ch_list.js, он сам генерирует готовый HTML-код для каждого игрока, используя логику из HtmlChar (ПК-версия) или filterProcRoom (ваш текущий код).
Замена содержимого: Он находит контейнер в оригинальном HTML (например, <td nowrap="">...</td>) и заменяет его содержимое на свой сгенерированный HTML-список.
Добавление UI-элементов: Он также добавляет выпадающий список навигации и кнопку "Свиток Обнаружения" прямо в сгенерированный HTML.
Этот подход гарантирует, что список будет отображаться независимо от состояния JavaScript-окружения, потому что он уже будет в виде чистого HTML.

Шаг 3: Обновить RoomManager.java как вспомогательный класс
Оставить в RoomManager.java только статические методы для парсинга (filterProcRoom) и генерации HTML (htmlChar).
ChListJs.java будет использовать эти методы для своей работы.
Это решение полностью соответствует архитектуре ПК-версии, где RoomManager.Process модифицирует HTML перед отображением, и избавляет от всех проблем с куками, фоновыми потоками и неработающим JS.